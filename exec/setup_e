#!/bin/ksh
## SETUP  SetUp General Circulation Model run  04/07/94
##           Usage: setup RUNID  /gcm1 N  (Storage_disk PrtOpt)
## Rundeck (RUNID.R), object modules, input data sets are assumed to
## reside in "/u/cmrun" of the current work station at least as symbolic
## linksr. The un will be executed in the directory /u/cmrun/RUNID which
## is really a symbolic link to /some_big_external_disk/RUNID
## Modified from setup by gas (06/00) to include:
##   - use current directory not /u/cmrun for object files
##   - checks links
##   - extra link from /u/cmrun to rundir
##   - output of WARN.f90 if compilation not successful
##   - added search for data files in /u/cmrun
##   - PROBLEM: $retc does not take STOP nn as the correct return code. Fixed
##   - changed files from numbers to names
##
    ## these should be set outside (Makefile?)
    ## should these program be part of the distribution?
    ## ie. $EXECDIR/prt  chop  runpm
## default settings
   CMRUNDIR="/u/cmrun"
   EXECDIR="/u/exec"
   SAVEDISK="/raid1"
   GCMSEARCHPATH="/u/cmrun"
   MAILTO=

## if ~/.modelErc is present get settings from there
   if [[ -f ~/.modelErc ]]; then
     echo "Using settings from ~/.modelErc"
     . ~/.modelErc
   else
     echo "~/.modelErc is not present. Using default settings."
   fi
   if [[ $MAILTO = '' ]]; then MAILTO=`whoami`; fi
   echo CMRUNDIR = $CMRUNDIR
   echo GCMSEARCHPATH = $GCMSEARCHPATH
   echo SAVEDISK = $SAVEDISK
   echo MAILTO = $MAILTO

   job=$( basename $0 )
   if [[ $# -eq 0 ]]; then
     echo "Usage: $job runID"; exit; 
   fi
   RUNID=$1
   RFILE=$1.R
   LOCKFILE=$SAVEDISK/$RUNID/lock
  BLANK=' '
  p=`pwd`
  Xdisk=$SAVEDISK
  CMRUN=$CMRUNDIR

## check if this run is already running
   if [[ -f $LOCKFILE ]]; then
     echo "            **********************                "
     echo "$1 seems to be already running in $SAVEDISK/$RUNID"
     echo "If you think it is an error, then most probably this"
     echo "task was interrupted in an unusual way. Please check."
     echo "Then remove the lock file:"
     echo "$LOCKFILE"
     echo "and restart the setup."
     echo "            **********************                "
     exit 1
   fi

## Use arg1 to create the run-directory
   if [[ ! -s $RFILE ]];
   then  echo File does not exist: $RFILE;  exit 1;  fi

   echo "setting up run $1"
   echo "output files are saved in $Xdisk/$1"

## Create the proper environment
   #  export XLFRTEOPTS=namelist=old:nlwidth=133
   umask 002

## Create the directory (symbolic link) ./RUNID if necessary
   if [[ ! -d $Xdisk/$RUNID ]]; then mkdir $Xdisk/$RUNID; fi
   chmod ugo+rxw $Xdisk/$RUNID
## Check that link is not already correct (added by gavin)
   if [[ -L $RUNID ]]; then
     if [[ `ls -l $RUNID | awk '{print $11}'` != $Xdisk/$RUNID ]] ; then
       rm $RUNID; fi
   else
     if [[ -d $RUNID ]]; then cp -rp $RUNID/* $Xdisk/$RUNID; fi
     rm -rf $RUNID 2> /dev/null ; ln -s $Xdisk/$RUNID $RUNID
   fi
## Also link to $CMRUN  (added by gavin)
   if [[ -L $CMRUN/$RUNID ]]; then
     if [[ `ls -l "$CMRUN/$RUNID" | awk '{print $11}'` != $Xdisk/$RUNID ]]
     then
       rm $CMRUN/$RUNID
       ln -s $Xdisk/$RUNID $CMRUN/$RUNID ; fi
   else
      ln -s $Xdisk/$RUNID $CMRUN/$RUNID
   fi

   echo "0Run $RUNID"  > $RUNID/$RUNID.PRT

## Move executable from current directory to $RUNID
   if [[ ! -f "$RUNID"_bin/$RUNID.exe ]] ; then 
     echo $RUNID.exe not found; exit 1; fi

   mv -f "$RUNID"_bin/$RUNID.exe $RUNID/$RUNID.exe

## Make RFILE the standard input
   exec < $RFILE

## Read RFILE until "Data input files:" is encountered
   read VAR1 VAR2 VAR3
   if [[ ! $VAR1 = $RFILE ]]
      then echo "inconsistent Naming: $RFILE is not $VAR1" ; exit ; fi
   echo "$BLANK""$VAR1 $VAR2 $VAR3" >> "$RUNID/"${RUNID}.PRT
   until  [[ $VAR1 = 'Data' && $VAR2 = 'input' ]]
   do
     read VAR1 VAR2 VAR3
     if [[ $? -ne 0 ]]
       then  echo '"Data input files"' not found in $RFILE;  exit 1;  fi
     echo "$BLANK""$VAR1 $VAR2 $VAR3" >> "$RUNID/"${RUNID}.PRT
   done

## Remove any old link and unlink files after switching to new directory
   cd $RUNID
   if [[ -a "$RUNID"ln ]] then rm "$RUNID"ln ; fi
   if [[ -a "$RUNID"uln ]] then rm "$RUNID"uln ; fi
## Use the subsequent information to create the link and unlink files
   while true
   do read VAR1 VAR2 VAR3
      if [[ $? -ne 0 ]]
      then echo '"Label and Namelist:"' not found in $RFILE; exit 3
      fi
      if [[ $VAR1 = 'Label' && $VAR2 = 'and' ]] then break ; fi
      echo "$BLANK"$VAR1 $VAR2 $VAR3 >> ${RUNID}.PRT
      if [[ $VAR1 != '' ]]
      then for i in $VAR1 $VAR2 $VAR3
      do if [[ $i = '!'* ]] ; then break ; fi
         n=${i%%'='*}
         t=${i##*'='}
         if [[ -a $GCMSEARCHPATH'/'$t ]] ; then pt=$GCMSEARCHPATH'/'$t
         else echo " $t NOT found in $GCMSEARCHPATH" ; exit 82
         fi
#  Make sure that linking works for numbers as well as names ie. n:=>fort.n
  if [[ `echo $n | grep "[A-Za-z]" ` == "" ]] ; then n=fort.$n ; fi
         if [[ $n != "AIC" && $n != "OIC" && $n != "GIC" && $n != "fort.9" ]]
         then echo ln -s ${pt} $n >> "$RUNID"ln
              echo rm $n >> "$RUNID"uln
         else ln -s ${pt} $n ; echo "using $pt for IC only"
         fi
      done
      fi
   done
   echo 'chmod ugo+rw * 2> /dev/null' >> ${RUNID}uln
   echo 'export PAGESIZE_DATA=64 PAGESIZE_STACK=64' >> ${RUNID}ln

## Copy Label and Namelist to RUNID.I.
   if [[ -a I ]] then rm I ; fi
## Compare beginning of label and RUNID
   read VAR1 VAR2 VAR3
   echo "$VAR1 $VAR2 $VAR3" > I
   if [[ ! $VAR1 = $RUNID  && ! $VAR1$VAR2 = $RUNID ]]
   then
       echo "inconsistent labelling: $RUNID is not start of $VAR1$VAR2"
       exit
   fi
   read LINE
   echo "$LINE" >> I
## remaining lines need a leading blank
   read LINE
   until [[ $? -ne 0 ]]
   do for i in $LINE    ## strip out comments
      do if [[ $i = '!'* ]] ; then break ; fi
       echo -n " $i" >> I
      done
      echo >> I
      read LINE
   done

## Run the 1st hour then clean up
   echo " starting the execution "
   echo " current dir is " `pwd`
   chmod ugo+x "$RUNID"ln
   chmod ugo+x "$RUNID"uln
   touch lock
   ./"$RUNID"ln
{  ./"$RUNID".exe < I >> ${RUNID}.PRT
   retc=$?
   rm -f AIC GIC OIC  #fort.[789]
   ./"$RUNID"uln
   rm -f lock
   if [[ $retc -ne 13 && $retc -ne 12 ]] then
     echo Problem encountered while running hour 1; exit 4 ;
   else
     echo 1st hour completed sucessfully
   fi

## create executable script file RUNID
   echo 'touch lock' > $RUNID
   echo "PRTFILE=${RUNID}.PRT"  >> $RUNID
   echo 'if [[ $# -ge 1 && $1 = "-q" ]]; then'  >> $RUNID
   echo '  PRTFILE="/dev/null"; fi' >> $RUNID
   echo "./$RUNID"ln >> $RUNID
   #  echo "export XLFRTEOPTS=namelist=old:nlwidth=133" >> $RUNID
   echo " ./$RUNID"'.exe < I > $PRTFILE' >> $RUNID
   echo ' rc=$? ' >> $RUNID
   echo "./$RUNID"uln >> $RUNID
   echo 'rm -f lock' >> $RUNID
   echo "exec $EXECDIR/runpmE $RUNID" '$rc' "$MAILTO" >> $RUNID
## end of RUNID script

   chmod ugo+x  $RUNID
## overwrite RUNID.I omitting ISTART=.. line.
   grep -v "ISTART=" I > I.tmp
   mv -f I.tmp I
   chmod go+rw *
} &



















