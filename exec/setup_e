#!/bin/ksh
## SETUP  SetUp General Circulation Model run  04/07/94
##           Usage: setup RUNID  /gcm1 N  (Storage_disk PrtOpt)
## Rundeck (RUNID.R), object modules, input data sets are assumed to
## reside in "/u/cmrun" of the current work station at least as symbolic
## linksr. The un will be executed in the directory /u/cmrun/RUNID which
## is really a symbolic link to /some_big_external_disk/RUNID
## Modified from setup by gas (06/00) to include:
##   - use current directory not /u/cmrun for object files
##   - checks links 
##   - extra link from /u/cmrun to rundir
##   - output of WARN.f90 if compilation not successful 
##   - added search for data files in /u/cmrun
##   - PROBLEM: $retc does not take STOP nn as the correct return code. Fixed
##   - changed files from numbers to names
##
   df /raid1 /raid2 /raid3 /raid4 > /dev/null
   job=$( basename $0 )
   if [[ $# -eq 0 ]]
   then echo "Usage: $job runID disk Noprt|Prt       (09/19/97)" ;
        echo "       defaults: disk=/raid1_if_avail_else/gcm2 Noprt" ;
        exit; fi
   if ps -ef | grep $1'[.]exe' > /dev/null
   then echo "$1 is already running" ;  exit ; fi
   if rsh Ra ps -ef | grep $1'[.]exe' > /dev/null
   then echo "$1 is already running on Ra" ;  exit ; fi
   if rsh Poncho ps -ef | grep $1'[.]exe' > /dev/null
   then echo "$1 is already running on Poncho" ;  exit ; fi

## Use arg1 to create the run-directory
   p=`pwd`  # use current directory to avoid conflicts with main code
            # gas 06/00 originally  p= '/u/cmrun' ; 
   cd $p ; RUNID=$1 ;  RFILE=$1.R ; BLANK=' ';
   if [[ ! -s $RFILE ]];
   then  echo File does not exist: $RFILE;  exit 1;  fi

## Use arg2 to find the disk to save rsf,acc etc files as /HOSTS/.....
   wkst=$(whereami) ;  # Name of machine in /HOSTS
   pfxH=/HOSTS/$wkst
   if [[ $wkst = '' ]] ; then pfxH='' ; fi ; # if whereami doesn't work
   Xdisk='/raid1' ; if [[ $# -gt 1 ]] ; then Xdisk=$2 ; fi
   if [[ $Xdisk != /* ]]; then Xdisk=/$Xdisk ; fi  ; # add / if needed
   if [[ ! -w $Xdisk ]] ; then echo "$Xdisk not available" ; exit ; fi
   if [[ -L $pfxH$Xdisk ]] ; then Xdisk=$pfxH$Xdisk ; fi ; # add /HOSTS/
   if [[ ! -d $Xdisk ]]                                  ; # if possible
   then echo "$Xdisk not found - please specify a save_disk"
        echo "Usage: $job $1 save_disk(full path)" ; exit ; fi

## arg3 is the Hard Copy Option
   PRT=${3:-'No_HardCopy'}

   echo "setting up run $1  PrintOption=$PRT ($job 9/19/97)"
   echo "output files are saved in $Xdisk/$1"

## Create the proper environment
   #  export XLFRTEOPTS=namelist=old:nlwidth=133
   umask 002
## Make RFILE the standard input
   exec < $RFILE

## Create the directory (symbolic link) ./RUNID if necessary
   if [[ ! -d $Xdisk/$RUNID ]]; then mkdir $Xdisk/$RUNID; fi
   chmod ugo+rxw $Xdisk/$RUNID
## Check that link is not already correct (added by gavin)
   if [[ -L $RUNID ]]; then
     if [[ `ls -l $RUNID | awk '{print $11}'` != $Xdisk/$RUNID ]] ; then
       rm $RUNID; fi
   else
     if [[ -d $RUNID ]]; then cp -rp $RUNID/* $Xdisk/$RUNID; fi
     rm -rf $RUNID 2> /dev/null ; ln -s $Xdisk/$RUNID $RUNID
   fi
## Also link to /u/cmrun  (added by gavin)
   if [[ -L /u/cmrun/$RUNID ]]; then
     if [[ `ls -l "/u/cmrun/$RUNID" | awk '{print $11}'` != $Xdisk/$RUNID ]] 
     then
       rm /u/cmrun/$RUNID
       ln -s $Xdisk/$RUNID /u/cmrun/$RUNID ; fi
   else
      ln -s $Xdisk/$RUNID /u/cmrun/$RUNID
   fi

   echo "0Run $RUNID"  > $RUNID/$RUNID.PRT

## Move executable from current directory to $p/$RUNID
   if [[ ! -f "$RUNID"_bin/$RUNID.exe ]] ; then echo $RUNID.exe not found; exit 1; fi

   mv -f "$RUNID"_bin/$RUNID.exe $p/$RUNID/$RUNID.exe

## Read RFILE until "Data input files:" is encountered
   read VAR1 VAR2 VAR3
   if [[ ! $VAR1 = $RFILE ]]
      then echo "inconsistent Naming: $RFILE is not $VAR1" ; exit ; fi
   echo "$BLANK""$VAR1 $VAR2 $VAR3" >> "$RUNID/"${RUNID}.PRT
   until  [[ $VAR1 = 'Data' && $VAR2 = 'input' ]]
   do
     read VAR1 VAR2 VAR3
     if [[ $? -ne 0 ]]
       then  echo '"Data input files"' not found in $RFILE;  exit 1;  fi
     echo "$BLANK""$VAR1 $VAR2 $VAR3" >> "$RUNID/"${RUNID}.PRT
   done

## Remove any old link and unlink files after switching to new directory
   cd $RUNID
   if [[ -a "$RUNID"ln ]] then rm "$RUNID"ln ; fi
   if [[ -a "$RUNID"uln ]] then rm "$RUNID"uln ; fi
## Use the subsequent information to create the link and unlink files
   while true
   do read VAR1 VAR2 VAR3
      if [[ $? -ne 0 ]]
      then echo '"Label and Namelist:"' not found in $RFILE; exit 3
      fi
      if [[ $VAR1 = 'Label' && $VAR2 = 'and' ]] then break ; fi
      echo "$BLANK"$VAR1 $VAR2 $VAR3 >> ${RUNID}.PRT
      if [[ $VAR1 != '' ]]
      then for i in $VAR1 $VAR2 $VAR3
      do if [[ $i = '!'* ]] ; then break ; fi
         n=${i%%'='*}
         t=${i##*'='}
         DIRS="$p/$RUNID $p Ra:/raid1 Ipcc2:/gcm1 Ra:/raid4 Ra:/u/cmrun"
         if [[ -a $t ]] then pt=$t
         elif [[ -a $p'/'$t ]] ; then pt=$p'/'$t
         elif [[ -a '/HOSTS/Ra/u/cmrun/'$t ]]
         then pt='/HOSTS/Ra/u/cmrun/'$t
         elif [[ -a '/HOSTS/Ra/raid1/'$t ]]
         then pt='/HOSTS/Ra/raid1/'$t
         elif [[ -a '/HOSTS/Ipcc2/gcm1/'$t ]]
         then pt='/HOSTS/Ipcc2/gcm1/'$t
         elif [[ -a '/HOSTS/Ipcc2/gcm1/'$t.gz && $n == "AIC" ]]
         then cp -p '/HOSTS/Ipcc2/gcm1/'$t.gz AIC.gz
              gunzip AIC.gz ; pt='/HOSTS/Ipcc2/gcm1/'$t.gz
              echo "uncompressing AIC; ignore ln-error msg"
         elif [[ -a '/HOSTS/Ra/raid4/'$t ]]
         then pt='/HOSTS/Ra/raid4/'$t
         else echo " $t NOT found in $DIRS" ; exit 82
         fi
#  Make sure that linking works for numbers as well as names ie. n:=>fort.n
	 if [[ `echo $n | grep "[A-Za-z]" ` == "" ]] ; then n=fort.$n ; fi
         if [[ $n != "AIC" && $n != "OIC" && $n != "GIC" && $n != "fort.9" ]] 
         then echo ln -s ${pt} $n >> "$RUNID"ln
              echo rm $n >> "$RUNID"uln
         else ln -s ${pt} $n ; echo "using $pt for IC only"
         fi
      done
      fi
   done
   echo 'chmod ugo+rw * 2> /dev/null' >> ${RUNID}uln
   echo 'export PAGESIZE_DATA=64 PAGESIZE_STACK=64' >> ${RUNID}ln

## Copy Label and Namelist to RUNID.I.
   if [[ -a I ]] then rm I ; fi
## Compare beginning of label and RUNID
   read VAR1 VAR2 VAR3
   echo "$VAR1 $VAR2 $VAR3" > I
   if [[ ! $VAR1 = $RUNID  && ! $VAR1$VAR2 = $RUNID ]]
   then
       echo "inconsistent labelling: $RUNID is not start of $VAR1$VAR2"
       exit
   fi
   read LINE
   echo "$LINE" >> I
## remaining lines need a leading blank
   read LINE
   until [[ $? -ne 0 ]]
   do for i in $LINE    ## strip out comments
      do if [[ $i = '!'* ]] ; then break ; fi
       echo -n " $i" >> I
      done
      echo >> I	
      read LINE 
   done

## Run the 1st hour then clean up
   chmod ugo+x "$RUNID"ln
   chmod ugo+x "$RUNID"uln
   "$RUNID"ln
{  "$RUNID".exe < I >> ${RUNID}.PRT
   retc=$?
   rm -f AIC GIC OIC  #fort.[789]
   "$RUNID"uln
   if [[ $retc -ne 13 && $retc -ne 12 ]] then
     echo Problem encountered while running hour 1; exit 4 ; 
   else
     echo 1st hour completed sucessfully
   fi

## move printout to M-disk after successful initialization
   if [[ $PRT = [Pp]* ]] then /u/exec/prt ${RUNID} ; fi
## prepare output for vi-editor (no lines longer than 133 characters)
   awk '{ print length($0) }' *.PRT | sort -n  | tail -1 | read width
   if [[ $width -gt 140 ]] ; then /u/exec/chop ${RUNID}.PRT > /dev/null
      mv ${RUNID}.PRT.chop ${RUNID}.PRT ; fi

## Prepare for restart
## create executable script file E
   echo "$RUNID"ln > E
   #  echo "export XLFRTEOPTS=namelist=old:nlwidth=133" >> E
   echo " ${RUNID}.exe < I > ${RUNID}.PRT " >> E
   echo "$RUNID"uln >> E
   chmod ugo+x  E
## create executable script file RUNID
   echo "$RUNID"ln > $RUNID
   #  echo "export XLFRTEOPTS=namelist=old:nlwidth=133" >> $RUNID
   echo " $RUNID"'.exe < I > /dev/null' >> $RUNID
   echo "$RUNID"uln >> $RUNID
   chmod ugo+x  $RUNID
## overwrite RUNID.I omitting ISTART=.. line.
   exec < I
   read LINE  ; echo "$LINE" >  "$RUNID".tmp
   read LINE  ; echo "$LINE" >> "$RUNID".tmp
   read LINE  ; echo ' '"$LINE" >> "$RUNID".tmp
#  echo ' ISTART=99,' >> "$RUNID".tmp
   while read LINE
   do if [[ $LINE != *'ISTART='* ]] then
        echo ' '"$LINE" >> "$RUNID".tmp
     fi
   done
   cp "$RUNID".tmp I
   rm "$RUNID".tmp
   chmod go+rw *

## Add Mail command to uln-file
   mkmsg="cat $RUNID.PRT nohup.out | tail -100 | "
   mkmsg="$mkmsg Mail -s $RUNID $( whoami )@giss.nasa.gov"
   echo $mkmsg >> ${RUNID}uln
} &
