#!/bin/sh
## setup_e - set up GCM modelE run
## This script is not supposed to be executed by users but rather
## is a part of Makefile functionality. It is run as a part of
##           gmake setup RUN=RunID
## Inside the Makefile it is called (from .../decks): setup_e RunID
## It looks for $HOME/.modelErc file and extracts all necessary options from
## there. If such file is not present the default options which are
## specified below will be used. Those default options are adjusted for
## working environment of ra.giss.nasa.gov.
##
## The options setup_e is looking for are:
## CMRUNDIR - directory to which all run directories will be linked.
## EXECDIR - path to directory with modelE scripts and with some executables.
## SAVEDISK - a directory (big) where all run directories will be created.
## GCMSEARCHPATH - directory to search for gcm input files.
## MAILTO - email address of the user. (default `whoami`)

## default settings
   CMRUNDIR="/u/cmrun"
   EXECDIR="/u/exec"
   SAVEDISK="/raid1"
   GCMSEARCHPATH="/u/cmrun"
   MAILTO=

## if $HOME/.modelErc is present get settings from there
   if [ -f $HOME/.modelErc ]; then
     echo "Using settings from $HOME/.modelErc"
     . $HOME/.modelErc
   else
     echo "$HOME/.modelErc is not present. Using default settings."
   fi
   if [[ $MAILTO = '' ]]; then MAILTO=`whoami`; fi
   echo CMRUNDIR = $CMRUNDIR
   echo GCMSEARCHPATH = $GCMSEARCHPATH
   echo SAVEDISK = $SAVEDISK
   echo MAILTO = $MAILTO

   job=$( basename $0 )
   if [[ $# -ne 1 ]]; then
     echo "This script is not supposed to be run outside of Makefile"
     echo "Inside the Makefile it is called: $job runID"; exit;
   fi
   RUNID=$1
   RFILE=$1.R
   LOCKFILE=$SAVEDISK/$RUNID/lock
   BLANK=' '
   Xdisk=$SAVEDISK
   CMRUN=$CMRUNDIR

## check if this run is already running
   if [[ -f $LOCKFILE ]]; then
     echo "            **********************                "
     echo "$1 seems to be already running in $SAVEDISK/$RUNID"
     echo "If you think it is an error, then most probably this"
     echo "task was interrupted in an unusual way. Please check."
     echo "Then remove the lock file:"
     echo "$LOCKFILE"
     echo "and restart the setup."
     echo "            **********************                "
     exit 1
   fi

## Use arg1 to create the run-directory
   if [[ ! -s $RFILE ]];
   then  echo File does not exist: $RFILE;  exit 1;  fi

   echo "setting up run $1"
   echo "output files are saved in $Xdisk/$1"

## Create the proper environment
   umask 002

## Create the run directory if necessary
   if [[ ! -d $Xdisk/$RUNID ]]; then mkdir $Xdisk/$RUNID
     if [[ $? -ne 0 ]]; then
       echo "Can't create $Xdisk/$RUNID. Aborting setup."
       exit 1; fi
   fi
   chmod ugo+rxw $Xdisk/$RUNID

## Check that link is not already correct (added by gavin)
   if [[ -e $RUNID ]]; then
     if [[ `ls -l $RUNID | awk '{print $11}'` != $Xdisk/$RUNID ]] ; then
       echo "./$RUNID exists and is pointing to something else."
       echo "Please check. Aborting setup.";  exit 1; fi
   else
     ln -s $Xdisk/$RUNID $RUNID
   fi

## Also link to $CMRUN if different from $Xdisk (added by gavin)
   if [[ $CMRUN != $Xdisk ]] ; then
     if [[ -L $CMRUN/$RUNID ]]; then
       if [[ `ls -l "$CMRUN/$RUNID" | awk '{print $11}'` != $Xdisk/$RUNID ]]
       then
         rm $CMRUN/$RUNID
         ln -s $Xdisk/$RUNID $CMRUN/$RUNID ; fi
     else
        ln -s $Xdisk/$RUNID $CMRUN/$RUNID
     fi
   fi

## Make sure that we really can write to dir/link $RUNID
   if [[ ! ( -d $RUNID && -r $RUNID && -w $RUNID && -x $RUNID ) ]] ; then
     echo "Couldn't create the link $RUNID"
     echo "or run directory has wrong permissions. Aborting setup."
     exit 1
   fi

   echo "0Run $RUNID"  > $RUNID/$RUNID.PRT

## Move executable from "$RUNID"_bin directory to $RUNID
   if [[ ! -f "$RUNID"_bin/$RUNID.exe ]] ; then
     echo $RUNID.exe not found; exit 1; fi

   mv -f "$RUNID"_bin/$RUNID.exe $RUNID/$RUNID.exe

## Make RFILE the standard input
   exec < $RFILE

## Read RFILE until "Data input files:" is encountered
   read VAR1 VAR2 VAR3
   if [[ ! $VAR1 = $RFILE ]]
      then echo "inconsistent Naming: $RFILE is not $VAR1" ; exit ; fi
   echo "$BLANK""$VAR1 $VAR2 $VAR3" >> "$RUNID/"${RUNID}.PRT
   until  [[ $VAR1 = 'Data' && $VAR2 = 'input' ]]
   do
     read VAR1 VAR2 VAR3
     if [[ $? -ne 0 ]]
       then  echo '"Data input files"' not found in $RFILE;  exit 1;  fi
     echo "$BLANK""$VAR1 $VAR2 $VAR3" >> "$RUNID/"${RUNID}.PRT
   done

## Remove any old link and unlink files after switching to new directory
   cd $RUNID
   if [[ -a "$RUNID"ln ]] ; then rm "$RUNID"ln ; fi
   if [[ -a "$RUNID"uln ]] ; then rm "$RUNID"uln ; fi
## Use the subsequent information to create the link and unlink files
   while true
   do read VAR1 VAR2 VAR3
      if [[ $? -ne 0 ]]
      then echo '"Label and Namelist:"' not found in $RFILE; exit 3
      fi
      if [[ $VAR1 = 'Label' && $VAR2 = 'and' ]] ; then break ; fi
      echo "$BLANK"$VAR1 $VAR2 $VAR3 >> ${RUNID}.PRT
      if [[ $VAR1 != '' ]]
      then for i in $VAR1 $VAR2 $VAR3
      do if [[ $i = '!'* ]] ; then break ; fi
         n=${i%%'='*}
         t=${i##*'='}
         if [[ -a $GCMSEARCHPATH'/'$t ]] ; then pt=$GCMSEARCHPATH'/'$t
         else echo " $t NOT found in $GCMSEARCHPATH" ; exit 82
         fi
#  Make sure that linking works for numbers as well as names ie. n:=>fort.n
  if [[ `echo $n | grep "[A-Za-z]" ` = "" ]] ; then n=fort.$n ; fi
         if [[ $n != "AIC" && $n != "OIC" && $n != "GIC" && $n != "fort.9" ]]
         then echo ln -s ${pt} $n >> "$RUNID"ln
              echo rm $n >> "$RUNID"uln
         else ln -s ${pt} $n ; echo "using $pt for IC only"
         fi
      done
      fi
   done
   echo 'chmod ugo+rw * 2> /dev/null' >> ${RUNID}uln

## Architecture-dependent settings
   case `uname` in
     IRIX64 )
            echo 'export PAGESIZE_DATA=64 PAGESIZE_STACK=64' >> ${RUNID}ln ;;
     AIX )
            echo 'export NAMELIST=OLD' >> ${RUNID}ln ;;
   esac

## Copy Label and Namelist to RUNID.I.
   if [[ -a I ]] ; then rm I ; fi
## Compare beginning of label and RUNID
   read VAR1 VAR2 VAR3
   echo "$VAR1 $VAR2 $VAR3" > I
   if [[ ! $VAR1 = $RUNID  && ! $VAR1$VAR2 = $RUNID ]]
   then
       echo "inconsistent labelling: $RUNID is not start of $VAR1$VAR2"
       exit
   fi
   read LINE
   echo "$LINE" >> I
## remaining lines need a leading blank
   while read LINE; do echo " ${LINE%%!*}" >> I ; done

## Run the 1st hour then clean up
   echo " starting the execution "
   echo " current dir is " `pwd`
   chmod ugo+x "$RUNID"ln
   chmod ugo+x "$RUNID"uln
   touch lock
   ./"$RUNID"ln
{  ./"$RUNID".exe < I >> ${RUNID}.PRT
   retc=$?
   rm -f AIC GIC OIC  #fort.[789]
   ./"$RUNID"uln
   rm -f lock
   if [[ $retc -ne 13 && $retc -ne 12 ]] ; then
     echo Problem encountered while running hour 1; exit 4 ;
   else
     echo 1st hour completed sucessfully
   fi

## create executable script file RUNID
   echo '#!/bin/sh' > $RUNID
   echo 'touch lock' >> $RUNID
   echo "PRTFILE=${RUNID}.PRT"  >> $RUNID
   echo 'if [[ $# -ge 1 && $1 = "-q" ]]; then'  >> $RUNID
   echo '  PRTFILE="/dev/null"; fi' >> $RUNID
   echo "./$RUNID"ln >> $RUNID
   #  echo "export XLFRTEOPTS=namelist=old:nlwidth=133" >> $RUNID
   echo " ./$RUNID"'.exe < I > $PRTFILE' >> $RUNID
   echo ' rc=$? ' >> $RUNID
   echo "./$RUNID"uln >> $RUNID
   echo 'rm -f lock' >> $RUNID
   echo "exec $EXECDIR/runpmE $RUNID" '$rc' "$MAILTO" >> $RUNID
   ln -sf $RUNID E 
## end of RUNID script

   chmod ugo+x  $RUNID
## overwrite RUNID.I omitting ISTART=.. line.
   grep -v "ISTART=" I > I.tmp
   mv -f I.tmp I
   chmod go+rw *
} &



















