#!/bin/ksh
## SETUP  SetUp General Circulation Model run  04/07/94
##           Usage: setup RUNID  /gcm1 N  (Storage_disk PrtOpt)
## Rundeck (RUNID.R), object modules, input data sets are assumed to
## reside in "/u/cmrun" of the current work station at least as symbolic
## linksr. The un will be executed in the directory /u/cmrun/RUNID which
## is really a symbolic link to /some_big_external_disk/RUNID
## Modified from setup by gas (06/00) to include:
##   - use current directory not /u/cmrun for object files
##   - checks links
##   - extra link from /u/cmrun to rundir
##   - output of WARN.f90 if compilation not successful
##   - added search for data files in /u/cmrun
##   - PROBLEM: $retc does not take STOP nn as the correct return code. Fixed
##   - changed files from numbers to names
##
    ## these should be set outside (Makefile?)
    ## should these program be part of the distribution?
    ## ie. $EXECDIR/prt  chop  runpm
## default settings
   CMRUNDIR="/u/cmrun"
   EXECDIR="/u/exec"
   SAVEDISK="/raid1"
   GCMSEARCHPATH="/u/cmrun"

## if ~/.modelErc is present get settings from there
   if [[ -f ~/.modelErc ]]; then
     echo "Using settings from ~/.modelErc"
     . ~/.modelErc
   else
     echo "~/.modelErc is not present. Using default settings."
   fi
   echo CMRUNDIR = $CMRUNDIR
   echo GCMSEARCHPATH = $GCMSEARCHPATH
   echo SAVEDISK = $SAVEDISK

   job=$( basename $0 )
   if [[ $# -eq 0 ]]; then
     echo "Usage: $job runID"; exit; 
   fi
   RUNID=$1
   RFILE=$1.R
   LOCKFILE=$SAVEDISK/$RUNID/lock
  BLANK=' '
  p=`pwd`
  Xdisk=$SAVEDISK
  CMRUN=$CMRUNDIR

## check if this run is already running
   if [[ -f $LOCKFILE ]]; then
     echo "            **********************                "
     echo "$1 seems to be already running in $SAVEDISK/$RUNID"
     echo "If you think it is an error, then most probably this"
     echo "task was interrupted in an unusual way. Please check."
     echo "Then remove the lock file:"
     echo "$LOCKFILE"
     echo "and restart the setup."
     echo "            **********************                "
     exit 1
   fi

## Use arg1 to create the run-directory
   if [[ ! -s $RFILE ]];
   then  echo File does not exist: $RFILE;  exit 1;  fi

   echo "setting up run $1  PrintOption=$PRT ($job 9/19/97)"
   echo "output files are saved in $Xdisk/$1"

## Create the proper environment
   #  export XLFRTEOPTS=namelist=old:nlwidth=133
   umask 002

## Create the directory (symbolic link) ./RUNID if necessary
   if [[ ! -d $Xdisk/$RUNID ]]; then mkdir $Xdisk/$RUNID; fi
   chmod ugo+rxw $Xdisk/$RUNID
## Check that link is not already correct (added by gavin)
   if [[ -L $RUNID ]]; then
     if [[ `ls -l $RUNID | awk '{print $11}'` != $Xdisk/$RUNID ]] ; then
       rm $RUNID; fi
   else
     if [[ -d $RUNID ]]; then cp -rp $RUNID/* $Xdisk/$RUNID; fi
     rm -rf $RUNID 2> /dev/null ; ln -s $Xdisk/$RUNID $RUNID
   fi
## Also link to $CMRUN  (added by gavin)
   if [[ -L $CMRUN/$RUNID ]]; then
     if [[ `ls -l "$CMRUN/$RUNID" | awk '{print $11}'` != $Xdisk/$RUNID ]]
     then
       rm $CMRUN/$RUNID
       ln -s $Xdisk/$RUNID $CMRUN/$RUNID ; fi
   else
      ln -s $Xdisk/$RUNID $CMRUN/$RUNID
   fi

   echo "0Run $RUNID"  > $RUNID/$RUNID.PRT

## Move executable from current directory to $RUNID
   if [[ ! -f "$RUNID"_bin/$RUNID.exe ]] ; then 
     echo $RUNID.exe not found; exit 1; fi

   mv -f "$RUNID"_bin/$RUNID.exe $RUNID/$RUNID.exe

## Make RFILE the standard input
   exec < $RFILE

## Read RFILE until "Data input files:" is encountered
   read VAR1 VAR2 VAR3
   if [[ ! $VAR1 = $RFILE ]]
      then echo "inconsistent Naming: $RFILE is not $VAR1" ; exit ; fi
   echo "$BLANK""$VAR1 $VAR2 $VAR3" >> "$RUNID/"${RUNID}.PRT
   until  [[ $VAR1 = 'Data' && $VAR2 = 'input' ]]
   do
     read VAR1 VAR2 VAR3
     if [[ $? -ne 0 ]]
       then  echo '"Data input files"' not found in $RFILE;  exit 1;  fi
     echo "$BLANK""$VAR1 $VAR2 $VAR3" >> "$RUNID/"${RUNID}.PRT
   done

## Remove any old link and unlink files after switching to new directory
   cd $RUNID
   if [[ -a "$RUNID"ln ]] then rm "$RUNID"ln ; fi
   if [[ -a "$RUNID"uln ]] then rm "$RUNID"uln ; fi
## Use the subsequent information to create the link and unlink files
   while true
   do read VAR1 VAR2 VAR3
      if [[ $? -ne 0 ]]
      then echo '"Label and Namelist:"' not found in $RFILE; exit 3
      fi
      if [[ $VAR1 = 'Label' && $VAR2 = 'and' ]] then break ; fi
      echo "$BLANK"$VAR1 $VAR2 $VAR3 >> ${RUNID}.PRT
      if [[ $VAR1 != '' ]]
      then for i in $VAR1 $VAR2 $VAR3
      do if [[ $i = '!'* ]] ; then break ; fi
         n=${i%%'='*}
         t=${i##*'='}
         if [[ -a $GCMSEARCHPATH'/'$t ]] ; then pt=$GCMSEARCHPATH'/'$t
### can I remove all the rest of these dirs ?
         elif [[ -a $t ]] ; then pt=$t
         elif [[ -a $p'/'$t ]] ; then pt=$p'/'$t
         elif [[ -a '/HOSTS/Ra'$CMRUN/$t ]]
         then pt='/HOSTS/Ra'$CMRUN/$t
         elif [[ -a '/HOSTS/Ra/raid1/'$t ]]
         then pt='/HOSTS/Ra/raid1/'$t
         elif [[ -a '/HOSTS/Ipcc2/gcm1/'$t ]]
         then pt='/HOSTS/Ipcc2/gcm1/'$t
         elif [[ -a '/HOSTS/Ipcc2/gcm1/'$t.gz && $n == "AIC" ]]
         then cp -p '/HOSTS/Ipcc2/gcm1/'$t.gz AIC.gz
              gunzip AIC.gz ; pt='/HOSTS/Ipcc2/gcm1/'$t.gz
              echo "uncompressing AIC; ignore ln-error msg"
         elif [[ -a '/HOSTS/Ra/raid4/'$t ]]
         then pt='/HOSTS/Ra/raid4/'$t
         else echo " $t NOT found in $DIRS" ; exit 82
         fi
#  Make sure that linking works for numbers as well as names ie. n:=>fort.n
  if [[ `echo $n | grep "[A-Za-z]" ` == "" ]] ; then n=fort.$n ; fi
         if [[ $n != "AIC" && $n != "OIC" && $n != "GIC" && $n != "fort.9" ]]
         then echo ln -s ${pt} $n >> "$RUNID"ln
              echo rm $n >> "$RUNID"uln
         else ln -s ${pt} $n ; echo "using $pt for IC only"
         fi
      done
      fi
   done
   echo 'chmod ugo+rw * 2> /dev/null' >> ${RUNID}uln
   echo 'export PAGESIZE_DATA=64 PAGESIZE_STACK=64' >> ${RUNID}ln

## Copy Label and Namelist to RUNID.I.
   if [[ -a I ]] then rm I ; fi
## Compare beginning of label and RUNID
   read VAR1 VAR2 VAR3
   echo "$VAR1 $VAR2 $VAR3" > I
   if [[ ! $VAR1 = $RUNID  && ! $VAR1$VAR2 = $RUNID ]]
   then
       echo "inconsistent labelling: $RUNID is not start of $VAR1$VAR2"
       exit
   fi
   read LINE
   echo "$LINE" >> I
## remaining lines need a leading blank
   read LINE
   until [[ $? -ne 0 ]]
   do for i in $LINE    ## strip out comments
      do if [[ $i = '!'* ]] ; then break ; fi
       echo -n " $i" >> I
      done
      echo >> I
      read LINE
   done

## Run the 1st hour then clean up
   echo " startting the execution "
   echo " current dir is " `pwd`
   chmod ugo+x "$RUNID"ln
   chmod ugo+x "$RUNID"uln
   touch lock
   ./"$RUNID"ln
{  ./"$RUNID".exe < I >> ${RUNID}.PRT
   retc=$?
   rm -f AIC GIC OIC  #fort.[789]
   ./"$RUNID"uln
   rm -f lock
   if [[ $retc -ne 13 && $retc -ne 12 ]] then
     echo Problem encountered while running hour 1; exit 4 ;
   else
     echo 1st hour completed sucessfully
   fi

## move printout to M-disk after successful initialization
   if [[ $PRT = [Pp]* ]] then $EXECDIR/prt ${RUNID} ; fi
## prepare output for vi-editor (no lines longer than 133 characters)
   awk '{ print length($0) }' *.PRT | sort -n  | tail -1 | read width
   if [[ $width -gt 140 ]] ; then $EXECDIR/chop ${RUNID}.PRT > /dev/null
      mv ${RUNID}.PRT.chop ${RUNID}.PRT ; fi

### Can we leave only either "$RUNID" or "E" ?

## Prepare for restart
## create executable script file E
   echo 'touch lock' > E
   echo "./$RUNID"ln >> E
   #  echo "export XLFRTEOPTS=namelist=old:nlwidth=133" >> E
   echo " ./${RUNID}.exe < I > ${RUNID}.PRT " >> E
   echo ' rc=$? ' >> E
   echo "./$RUNID"uln >> E
   echo "$EXECDIR/runpm $RUNID" '$rc' "$( whoami )" >> E
   echo 'rm -f lock' >> E
   chmod ugo+x  E
## create executable script file RUNID
   echo 'touch lock' > $RUNID
   echo "./$RUNID"ln >> $RUNID
   #  echo "export XLFRTEOPTS=namelist=old:nlwidth=133" >> $RUNID
   echo " ./$RUNID"'.exe < I > /dev/null' >> $RUNID
   echo ' rc=$? ' >> $RUNID
   echo "./$RUNID"uln >> $RUNID
   echo "$EXECDIR/runpm $RUNID" '$rc' "$( whoami )" >> $RUNID
   echo 'rm -f lock' >> $RUNID
   chmod ugo+x  $RUNID
## overwrite RUNID.I omitting ISTART=.. line.
   exec < I
   read LINE  ; echo "$LINE" >  "$RUNID".tmp
   read LINE  ; echo "$LINE" >> "$RUNID".tmp
   read LINE  ; echo ' '"$LINE" >> "$RUNID".tmp
#  echo ' ISTART=99,' >> "$RUNID".tmp
   while read LINE
   do if [[ $LINE != *'ISTART='* ]] then
        echo ' '"$LINE" >> "$RUNID".tmp
     fi
   done
   cp "$RUNID".tmp I
   rm "$RUNID".tmp
   chmod go+rw *
} &
