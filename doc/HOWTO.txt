HOW-TO document for the GCM
===========================

This document outlines how to achieve some commonly sought results with
the new modelE. Some of the procedures will be the same as previously,
but it is more likely that the details will have become slightly more
straightforward (hopefully!). However, due to the modularization that
has been done, you are no longer free to do things in an arbitrary
way, see the notes below for more details. Please feel free to add to
this document.

This is only part of the documentation, you can find additional
information in the glossary of terms, the Frequently Asked Questions
(FAQ) file, the description of current functionality and options, or
the index of all prognostic variables.

The document is set up in three parts: Part I deals with running the
model for basic users who do not need to know how to alter the
code. Part II dealing with examining the diagnostics, while Part III
deals with more technical issues involved in adding functionality or
diagnostics.

PART I: Basic user information

1) HOW-TO setup and run the GISS GCM:
   1a: Generalities
   1b: How to tune a specified ocean run (using U00wtr)
   1c: How to set up a Q-flux model with a single ocean layer
   1d: How to set up a Q-flux model with diffusion into a deep ocean
2) HOW-TO produce a rundeck
3) HOW-TO use NAMELIST INPUT parameters
   3a: How to set and alter them
   3b: How to use them to control numerical instabilities
   3c: How to use IRAND to create an ensemble of runs
4) HOW-TO stop and restart the GCM
5) HOW-TO change boundary conditions
6) HOW-TO change trace gas amounts
7) HOW-TO have a perpetual winter
8) HOW-TO travel back/forward in time
9) HOW-TO move to Mars
10) HOW-TO get help
11) HOW-TO report a problem
12) HOW-TO keep up-to-date
13) HOW-TO add to this documentation

Part II: Getting information from the diagnostics

1) HOW-TO analyse the printout
2) HOW-TO change what is included in the printout
3) HOW-TO produce daily/monthly or seasonal diagnostics
3) HOW-TO produce useful diagnostics from the ACC file
4) HOW-TO produce netcdf/hdf output

Part III: The model code

1) HOW-TO find where a variable is defined
2) HOW-TO follow the program structure
3) HOW-TO use or add to the automatic documentation
4) HOW-TO ensure that your code meets the new standards
5) HOW-TO add functionality - A: variations on existing code
6) HOW-TO add functionality - B: introducing new sub-modules
7) HOW-TO add functionality - C: introducing a new NAMELIST parameter
8) HOW-TO add functionality - D: adding new diagnostics
9) HOW-TO read in an external file
10) HOW-TO add new variables to the restart files
11) HOW-TO access variables that are already calculated somewhere else
12) HOW-TO deal with the inevitable bugs you introduce
13) HOW-TO get an innovation included in everybody's versions

=====================================================================

Part I: Basic user tasks

1) HOW-TO setup and run the GISS GCM:
   1b: How to TUNE a specified ocean run (using U00wtr)
       It is desirable to run a specified ocean model in such a way that
       it is in RADIATIVE BALANCE, i.e. that the net flux of energy into
       the ocean (which has no effect, since ocean data are specified)
       is zero if averaged over a whole year. One way to roughly achieve
       this goal is to pick the right value for U00wtr. That parameter
       influences the cloud formation where the temperature is above 0C
       and can therefore be used to change the radiative balance.

       Run the model for a year and find the annual mean net heating at
       the ground (budget page). That quantity may change from year to
       year within 1/2 W/m2 . Increasing U00wtr by .01 increases that
       quantity by about .3 W/m2 . Rerun that year with a new value of
       U00wtr hoping that the annual mean net heating at the ground
       averages out to less than .3 W/m2 in absolut value over the next
       few years.

       Increasing U00ice works in the opposite direction but changes
       the global cloud cover considerably. It could be used to tune
       the cloud cover (before picking the final U00wtr).

       Other ways to handle the rad.balance problem: Change the solar
       constant until rad. balance results (most people hate that way),
       change the solar irradiance into the ocean when running the
       Qflux model (using the old SRCOR parameter) offsetting the
       imbalance (advantage: no need to repeat the control run,
       disadvantage: Jim hated it, no longer part of the code).

   1c: How to set up a Q-flux model with a single ocean layer
       A preliminary run with prescribed climatological ocean has to
       be run for about 6 years collecting daily fluxes into the ocean
       (Kvflxo=1). Based on these data, a new input file (OTSPEC...)
       has to be created that specifies the horizontal heat transports
       in the ocean; in addition, the ocean temperatures at the annual
       maximum mixed layer depth and the mean temperature between that
       level and the bottom of the current mixed layer depth have to be
       computed for the final time of the preliminary run and added to
       the final restart file of that preliminary run. That augmented
       restart file will serve as initial state file for the new run.
       During the first few years, monitor the time series of global
       annual means of  Ocean Ice Cover  and  Surface Air Temperature.
       Hopefully, they will no longer change after a few years (10-25).
       The model is said to be in balance as soon as that happens.

   1d: How to set up a Q-flux model with diffusion into a deep ocean
       Such a run needs a preliminary Q-flux model running for 10 years
       in equilibrium, saving (KCOPY=3) the data necessary for diffusion
       computations (see /u/cmrun/model/notes/deep.ocean.doc)

2) HOW-TO produce a rundeck


3) HOW-TO use NAMELIST parameters

   3a: How to set and alter NAMELIST parameters
       Namelist parameters take the default values unless they are
       specified in the rundeck between the lines &INPUTZ and &END .

       To start a run, the following parameters HAVE to be explicitly
       set: ISTART=2 | 7 or 8 to start from obs | model Initial State
            PLTOP(L) = pressure (mb) at top of layer L (L=1,...,LM)
            YEARI    = year in which model starts
            YEARE (or IHOURE) = year (or hour) at which model stops

       After a run is started, some parameters may be changed during
       the run:      1:    edit the file 'I' in the run directory,
                     2:    stop and restart the run,
                     3:    re-edit I to ready it for the next restart
       (If the change affects the results, attach a log of all such    
        changes to the end of the rundeck)

       For a list and explanation of all parameters see
          /u/exec/docE/NLparams.txt.

   3b: How to use NAMELIST parameters to control numerical instabilities
       Parameter   affects:                   depends on:
       DT          stability at poles         hor. resolution, AVRX
       NIsurf      stability at the surface   vert.resolution near surf
       XcdLM       stability at the top       model top pressure PMTOP
       M/NFILTR    checker board patterns     dynamics scheme

   3c: How to use IRAND to create an ensemble of runs
       If ISTART<9 and IRAND<0, all atmospheric initial temperatures 
       are randomly perturbed by at most 1C . The perturbations depend
       on the value of IRAND (since -IRAND is used as the first seed).
       After the perturbations, IRAND is reset to its default 123456789.
       So to create an ensemble of N runs whose only difference is the
       initial state they start up from, pick N (odd) negative numbers
       and create N copies of the rundeck that only differ in the runID
       and the value set for IRAND. Make sure, IRAND is set on the SAME
       LINE as ISTART, so that IRAND=-.... is not kept in the 'I'-file
       and used in restarts.

4) HOW-TO stop and restart the GCM


5) HOW-TO change boundary conditions

6) HOW-TO change trace gas amounts

7) HOW-TO have a perpetual winter

8) HOW-TO travel back/forward in time

9) HOW-TO move to Mars

10) HOW-TO get help

11) HOW-TO report a problem

12) HOW-TO keep up-to-date

13) HOW-TO add to this documentation


Part II: Getting information from the diagnostics

1) HOW-TO analyse the printout
2) HOW-TO change what is included in the printout
3) HOW-TO produce daily/monthly or seasonal diagnostics
3) HOW-TO produce useful diagnostics from the ACC file
4) HOW-TO produce netcdf/hdf output



Part III: The model code

1) HOW-TO find where a variable is defined

Variables (other than purely local variables) are defined in three
main ways. Physical constants (real constants, not tuning parameters),
are defined in const.f, model related variables (i.e. variables to do
with how the model is run) are defined in E001M12_COM.f, and all other
variables are defined in the physics MODULES. Variables that are on
the model grid will be defined in the PHYS_COM module, while
parameters and options for the local physics will be defined in the
PHYS module. Thus decide to which physics module your variable is most
related to and look there.

For more brute force efforts, run the utility 'gcmdoc RUNNAME'. This
will create a html document that indexes and defines all important
variables (well not all, but most, ok some!). Alternatively grep -i
"varname.*=" *.[fSU] will probably find it for you.

2) HOW-TO follow the program structure

The model is essentially on three levels. MAIN in ME001M12 is the
top level and controls the time-stepping and deals with most of the
model overhead. The time-step loop in MAIN is the principal path that
the model follows. This is a very linear loop, and therefore is not
difficult to understand.

The level below this is the level of the drivers. These are routines
that translate model variables (ie. those defined on the model grid),
to local variables (usually, but not always, vertical arrays), save
diagnostics and save variables/fluxes for later use.

Finally the third level is the level at which the actual physics gets
done. This level generally is oblivious to the previous two levels and
is code that could be used in many different contexts. It is very
important to keep this true. DO NOT write directly to model arrays
within a local physics subroutine. (Some outstanding cases may appear
to do that, but this is being written out of the model).

3) HOW-TO use or add to the automatic documentation

You will have noticed that modelE has multiple documentation
directives such as !@var or !@sum. These are key words that can be
read by a script and turned into useful documentation. Each
subroutine, and each important variable should have such a declaration
(which should include a definition, units, etc.). The utility 'gcmdoc'
makes html output from a rundeck containing (and sorting out) all this
information. The various directives are all defined in the main model
common block. If you introduce new variables or subroutines, you MUST
define similar documentation.

4) HOW-TO ensure that your code meets the new standards

Please check the document "Coding standards for ModelE" and try to
conform as nearly as possible to the (not very onerous)
conditions. Unfortunately, we do not have anybody whose job it is to
make sure that added code conforms. However, every time this happens
it makes it harder to keep the model consistent, and leads to the
creation of unnecessary complications in keeping things straight.

5) HOW-TO add functionality - A: variations on existing code


6) HOW-TO add functionality - B: introducing new sub-modules


7) HOW-TO add functionality - C: introducing a new NAMELIST parameter

Only introduce a new NAMELIST parameter if you would like to be able
to vary it's value at run time without recompiling the model (i.e. an
adjustable parameter, or an option switch for instance). Firstly,
decide who should own the parameter. That is likely to be one of the
physics modules. Since it is likely to be a fundamental part of a
local physics process, it should be declared and defined in the local
physics module. You now need to USE it in the physics COM block (this
is to allow the input/ouput routines to access it easily). In INPUT,
you should then USE this parameter from the COM block. This is a
little indirect but it cuts down on dependencies and is neater. Then
the variable can be added to the NAMELIST. You will probably also need
to add this parameter to the rsf/acc files for future reference - see
Q9 for details.

8) HOW-TO add functionality - D: adding new diagnostics

The diagnostic system that the GCM uses is very sophisticated and is
almost certainly sufficient for any new need for diagnostics that
arises. However, it can seem complex and difficult to use. As
improvements in ease of use occur, it will get easier to modify.

a) Adding a new conservation diagnostic: These arrays keep track of
the zonal average of any quantity, and note which routines change
those values. They are useful in undestanding the overall
mass/energy/tracer budgets. To add a new conservation quantity, first
write a routine that returns the zonally averaged quantity in
question. Secondly, in the 'init' subroutine for the relevant physical
module, insert a call to 'SET_CON' this sets up the points at which
the diagnostic is called, and how it is output. (see init_DIAG for
more detailed instructions). Thirdly, you must increase NQUANT by 1,
and KCON by 2+number of points at which you are saving the value.

Other diagnostics will be explained if and when I work them out.

9) HOW-TO read in an external file

ModelE has introduced a FILEMANAGER system that controls the
assignment of unit numbers and the opening of files. To add a new file
to be read in, first define a short mnemonic for the file
(i.e. "TRSRC" for the tracer source file). This is the name
that you will assign in the rundeck to the file you wish to
open. Secondly, prior to reading in the file, use the routine
'getunit' to assign a unit number for the file using the mnemonic you
gave it. ie.

     USE FILEMANAGER
     INTEGER iu_trc1
     ....
     call getunit("TRSRC",iu_trc1,.TRUE.,.TRUE.)
     READ(iu_trc1) DATA1,DATA2....

The first logical variable argument is true if the file is to be
opened for unformatted (binary) read/write, .FALSE. for ASCII
input. The second logical variable denotes whether this is an already
existing file or not. The line in the rundeck should look something
like (depending on the filename of course):

TRSRC=tracer_sources.1970_1980.dat

The setup script looks automatically in /u/cmrun, /u/raid and in the
current directory. If the file is elsewhere an absolute or relative
pathname is needed.

10) HOW-TO add new variables to the restart files

Each module now has only one place that needs to be changed to
accomodate extra variables in the rsf files: io_xyz (where xyz is a
descriptor for the module like ocean, rad, lakes etc.). All
input/output is controlled by these routines. Thus to add a new
variable, simply add it to the list of variables for both the read and
the write statements. Note that you MUST change the MODULE_HEADER
character string if you change what is in the rsf (ie. increment the
number by 1 each time you do this). This is necessary to ensure that
we can distinguish various versions.

There are some complications for variables that can be set in the
NAMELIST, namely, you must decide how this variable gets set as a
function of the initialisation method. Look at io_rad as an example to
follow.

10) HOW-TO access variables that are already calculated somewhere else

One of the main changes to modelE was to replace common blocks with
Fortan 90 modules. The functionality is much the same, but since they
do not assume anything about where in memory variables are kept, many
of the problems associated with common blocks are alleviated. In order
to make use of a variable from somewhere else in the code, that
variable must be in the relevant MODULE (usually called PHYS_COM, for
ease of remembering). Then in the routine of the module where you wish
to use it you must specifically declare what you want using the USE
statement. For clarity, we are insisting upon using 'USE, only' so
that each variable that you require is explicitly declared, ie.

    USE PHYS_COM, only : var1,var2

If the name of the variable conflicts with a local variable, you can
use the 'points-to' feature to map the PHYS_COM variable to a new name
(as you may have done with common blocks), i.e.

    USE PHYS_COM, only : var1,var2_phys=>var2

The arrow should be read as 'points to', and thus var2_phys will be an
alias for var2 in this routine/module only.

12) HOW-TO deal with the inevitable bugs you introduce

Nobody's code is perfect (least of all ours) and so when coding it is
inevitable that errors are introduced. Some are minor and cause no
obvious sign of distress (these are very difficult to find!), while
others cause the model to crash and burn.

Let's say you've changed something in the model that seemed innocuous,
and then the model crashes. There are three common points that seem to
trap errors: the dynamics, the radiation and the PBL scheme. These
errors will be flagged as either "A>1 in AADVTX" or similar (for
crashes in the dynamics), "In Radia: TL out of range" or similar (in
the radiation), and finally "stop zbrent" or "stop rtsafe", for a
crash in the PBL.

Do not go looking for errors in any of these routines. What has
generally happened is that you have introduced some wild fluctuation
in some main variable (the temperature, humidity or velocities), or
overwritten some the model variables that control advection and the
like. Check that coming out of the routine you modified, everything is
as it should be (set QCHECK in the rundeck, and include a call to
CHECKT immediately before and after). Also do not bother commenting
out the routine that actually crashed to see if the model can continue
on okay. This routine is the symptom, not the disease.

One additional problem that arises mainly with tracer code is that the
advection code can sometimes produce wild oscillations of the tracer
concentration, which for sensitive tracer physics, can cause no end of
problems. Again, the advection is not to blame! What has happened here
is that the second order moments for the tracer field (the first and
second derivatives at the centre of the grid-box) have somehow become
uncoupled from the mean tracer amount, giving rise to an implied
sub-grid scale profile that is seriously wrong. The biggest mistake is
not to reduce the gradients by the same fraction by which the mean was
reduced in some process. See the document "Using the GISS GCM tracer
moments" for more details on how to do this properly. The CLD01.f
tracer code is a good example of what to do.

13) HOW-TO get an innovation included in everybody's versions

Still working on this one!
