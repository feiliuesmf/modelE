HOW-TO document for the GCM
===========================

This document outlines how to achieve some commonly sought results with
the new modelE. Some of the procedures will be the same as previously,
but it is more likely that the details will have become slightly more
straightforward (hopefully!). However, due to the modularization that
has been done, you are no longer free to do things in an arbitrary
way, see the notes below for more details. Please feel free to add to
this document.

This is only part of the documentation, you can find additional
information in the glossary of terms, the Frequently Asked Questions
(FAQ) file, the description of current functionality and options, or
the index of all prognostic variables.

The document is set up in three parts: Part I deals with running the
model for basic users who do not need to know how to alter the
code. Part II dealing with examining the diagnostics, while Part III
deals with more technical issues involved in adding functionality or
diagnostics.

PART 0: Getting the code

PART I: Basic user information

1) HOW-TO setup and run the GISS GCM:
3) HOW-TO set rundeck parameters
   3a: How to set and alter them
   3b: How to use them to control numerical instabilities
   3c: How to use IRAND to create an ensemble of runs
   1b: How to tune a specified ocean run (using U00wtr)
   1c: How to set up a Q-flux model with a single ocean layer
   1d: How to set up a Q-flux model with diffusion into a deep ocean
4) HOW-TO stop and restart the GCM
5) HOW-TO change boundary conditions
6) HOW-TO change trace gas amounts
7) HOW-TO have a perpetual winter
8) HOW-TO travel back/forward in time
9) HOW-TO move to Mars
10) HOW-TO get help
11) HOW-TO report a problem
12) HOW-TO keep up-to-date
13) HOW-TO add to this documentation

Part II: Getting information from the diagnostics

1) HOW-TO analyse the printout
2) HOW-TO change what is included in the printout
3) HOW-TO produce daily/monthly or seasonal diagnostics
3) HOW-TO produce useful diagnostics from the ACC file
4) HOW-TO produce netcdf/hdf output

Part III: The model code

1) HOW-TO find where a variable is defined
2) HOW-TO follow the program structure
3) HOW-TO use or add to the automatic documentation
4) HOW-TO ensure that your code meets the new standards
5) HOW-TO add functionality - A: variations on existing code
6) HOW-TO add functionality - B: introducing new sub-modules
7) HOW-TO add functionality - C: introducing a new NAMELIST parameter
8) HOW-TO add functionality - D: adding new diagnostics
9) HOW-TO read in an external file
10) HOW-TO add new variables to the restart files
11) HOW-TO access variables that are already calculated somewhere else
12) HOW-TO deal with the inevitable bugs you introduce
13) HOW-TO get an innovation included in everybody's versions

Finally, CREDITS where CREDITS are due:

For ongoing development (who to blame for the current shambles):
	Gavin Schmidt,	Reto Ruedy,	Jean Lerner,	Max Kelley,
	Igor Aleinov,	Gary Russell,	Ye Cheng,	Andy Lacis,
	M. S. Yao.  

Historical development (stuff we haven't rewritten yet):
	Bob Suozzo,	Suki Sheth,	Hans-Peter Zinn,	Rick Healy,
        Frank Abramopoulos

Inspiration (the people paying for this):
	David Rind, Jim Hansen, Tony Del Genio

=====================================================================

Part 0: Getting the code

The modelE code including source code, scripts and some documentation. 
This is stored through the CVS revision control system, and copies can
be checked-out to your home directory using the following commands:
   export CVSDIR=/u/cmrun/cvs/repository
   cvs checkout -r rel-1.0 modelE
   cvs tag -b your_tag_here

This will create a directory modelE/ in your directory. The code will
correspond to rel-1.0 - the first release. It will be tagged with your
own tag name so that your developments can be maintained by CVS, without
conflicting with the main development branch. 

Please subscribe to the mailing list 'giss-gcm-users-l@giss.nasa.gov' 
by sending a message to Majordomo@giss.nasa.gov with a line 

SUBSCRIBE giss-gcm-users-l

in the body of the text. This is to ensure that you are notified of
bug fixes and new releases. Also this is a forum for you to ask
questions about the model.

Part I: Basic user tasks

1) HOW-TO setup and run the GISS GCM:

In order to run the GCM a 'rundeck' file (with a suffic .R) must be
created. This contains information about the run you would like to
perform, the fortran code that you intend to use, pre-processing
options that are required, the boundary and initial conditions and any
run-specific parameters (such as the time step, length of run
etc.). Most of the specifics have been automated using 'gmake'.

The sub-directory 'decks' is the main control directory, most commands
will be issued in this directory. Typing 'gmake' will produce some
documentation. 

There are three sample rundecks: E001.R, E001A.R and E001B.R. These
represent a standard fixed SST atmosphere only run, a Qflux run and a
coupled ocean-atmosphere run, respectively. In order to make a rundeck
that you can use and modify, type

     gmake mkrun RUN=E001xyz

This will make a rundeck E001xyz.R (please use a unique name, based on
your initials), that will be a copy of E001.R. To make a copy based on
another of the sample decks, use, for instance,

     gmake mkrun RUN=E001xyz RUNSRC=E001A

The list of fortran files within the rundeck determines which files
are compiled into the executable. The compilation is automatic, and
will take account of all dependencies, so that if a file is modified
it will be re-compiled, along with any files that directly depend on
modules or routines within it. The executable is made using

     gmake gcm RUN=E001xyz

To actually run the model, you must first 'setup' the run by running
the first hour (or specifically the first source time step).

    gmake setup RUN=E001xyz

If this runs successfully there will be a message saying so. Once this
is done, you can "run E001xyz" to set the model running for the
specified length of time.

3) HOW-TO set rundeck parameters

   3a: How to set and alter NAMELIST parameters
       Namelist parameters take the default values unless they are
       specified in the rundeck between the lines &INPUTZ and &END .

       To start a run, the following parameters HAVE to be explicitly
       set: ISTART=2 | 7 or 8 to start from obs | model Initial State
            PLTOP(L) = pressure (mb) at top of layer L (L=1,...,LM)
            YEARI    = year in which model starts
            YEARE (or IHOURE) = year (or hour) at which model stops

       After a run is started, some parameters may be changed during
       the run:      1:    edit the file 'I' in the run directory,
                     2:    stop and restart the run,
                     3:    re-edit I to ready it for the next restart
       (If the change affects the results, attach a log of all such    
        changes to the end of the rundeck)

       For a list and explanation of all parameters see
          /u/exec/docE/NLparams.txt.

   3b: How to use NAMELIST parameters to control numerical instabilities
       Parameter   affects:                   depends on:
       DT          stability at poles         hor. resolution, AVRX
       NIsurf      stability at the surface   vert.resolution near surf
       XcdLM       stability at the top       model top pressure PMTOP
       M/NFILTR    checker board patterns     dynamics scheme

   3c: How to use IRAND to create an ensemble of runs
       If ISTART<9 and IRAND<0, all atmospheric initial temperatures 
       are randomly perturbed by at most 1C . The perturbations depend
       on the value of IRAND (since -IRAND is used as the first seed).
       After the perturbations, IRAND is reset to its default 123456789.
       So to create an ensemble of N runs whose only difference is the
       initial state they start up from, pick N (odd) negative numbers
       and create N copies of the rundeck that only differ in the runID
       and the value set for IRAND. Make sure, IRAND is set on the SAME
       LINE as ISTART, so that IRAND=-.... is not kept in the 'I'-file
       and used in restarts.

   1b: How to TUNE a specified ocean run (using U00wtr)
       It is desirable to run a specified ocean model in such a way that
       it is in RADIATIVE BALANCE, i.e. that the net flux of energy into
       the ocean (which has no effect, since ocean data are specified)
       is zero if averaged over a whole year. One way to roughly achieve
       this goal is to pick the right value for U00wtr. That parameter
       influences the cloud formation where the temperature is above 0C
       and can therefore be used to change the radiative balance.

       Run the model for a year and find the annual mean net heating at
       the ground (budget page). That quantity may change from year to
       year within 1/2 W/m2 . Increasing U00wtr by .01 increases that
       quantity by about .3 W/m2 . Rerun that year with a new value of
       U00wtr hoping that the annual mean net heating at the ground
       averages out to less than .3 W/m2 in absolute value over the next
       few years.

       Increasing U00ice works in the opposite direction but changes
       the global cloud cover considerably. It could be used to tune
       the cloud cover (before picking the final U00wtr).

       Other ways to handle the rad. balance problem: Change the solar
       constant until rad. balance results (most people hate that way),
       change the solar irradiance into the ocean when running the
       Qflux model (using the old SRCOR parameter) offsetting the
       imbalance (advantage: no need to repeat the control run,
       disadvantage: Jim hated it, no longer part of the code).

   1c: How to set up a Q-flux model with a single ocean layer
       A preliminary run with prescribed climatological ocean has to
       be run for about 6 years collecting daily fluxes into the ocean
       (Kvflxo=1). Based on these data, a new input file (OTSPEC...)
       has to be created that specifies the horizontal heat transports
       in the ocean; in addition, the ocean temperatures at the annual
       maximum mixed layer depth and the mean temperature between that
       level and the bottom of the current mixed layer depth have to be
       computed for the final time of the preliminary run and added to
       the final restart file of that preliminary run. That augmented
       restart file will serve as initial state file for the new run.
       During the first few years, monitor the time series of global
       annual means of  Ocean Ice Cover  and  Surface Air Temperature.
       Hopefully, they will no longer change after a few years (10-25).
       The model is said to be in balance as soon as that happens.


       To run the Q-flux model it is necessary to supply the implied 
       horizontal heat transports and proper initial condition as 
       input files. To calculate the horizontal ocean heat transports 
       it is necessary to run the model with prescribed ocean mixed 
       layer temperature and sea ice extent for 5-6 years. It is 
       desirable to have this control run well balanced (Net Heat at
       z0 is supposed to be close to 0 for annual mean. This Net  
       Heat at z0 can be found on the first budget page for the global 
       quantities. To get the balanced control run, you can adjust 
       U00wtr (see 1b). In your control run-decks, you have to have
       Kvflxo=1. Then the model will save the data for the heat 
       tansport.  
       	    
       For the ocean heat transport calculation, it is necessary to 
       skip the first year of this control run because of the spin-up 
       of the atmosphere. For this calculation you need to do next 
       (suppose your control run is RunIDcontrol): 
       	    
       (a) go to your ../modelE/decks directory and do 
       	   gmake aux RUN=RunIDcontrol. This will create executables 
       	   for the ocean heat transport calculation and it will put 
       	   them to the directory ../modelE/decks/RunIDcontrol_bin. 
       	    
       (b) go to your ../modelE/aux directory and 
       	    
       	   (1) do a symbolic link of the restart file of your control 
       	       run, which you would like to use as a start-up for your 
       	       Q-flux model, to fort.1 (Usually this restart is the last 
       	       December restart file of the control run. But someone 
       	       might want to start the Q-flux model Dec. 1 in order to 
       	       have the complete December-January-February season, then 
       	       you would need to link the last year November restart file
       	       to fort.1. It is really up to you which restart you choose 
       	       for your Q-flux start-up).
       	    
       	   (2) do mkOTSPEC.E001.M250D RunIDcontrol first_month first_year 
       	       last_month last_year, 
       	       where first_month and first_year are the first month and 
       	       the first year of your control run you start the ocean heat 
       	       transport calculation, last_month and last_year are the 
       	       last month and the last year of your control run you end up 
       	       the transport calculation. 
       	       Usually first_month=1, first_year=1951, last_month=12, 
       	       last_year=1955 if you did run your control model for 6 years 
       	       starting Jan.1 1950. 
       	    
       After this you will get two files which you will use as unput data 
       for your Q-flux model: 
       1. OTSPEC.RRunIDcontrol.M250D.first_year-last_year 
       	  This file is the implied ocean heat transport data. In your 
       	  Q-flux run-deck the input file OHT has to have this name, in 
       	  other words OHT=OTSPEC.RRunIDcontrol.M250D.first_year-last_year.
       	  You have to move this file to /u/cmrun directory.  
       2. IMJAN.RunIDcontrol.O250D is the corrected restart for your 
       	  Q-flux model. This restart is basicly is the same restart as your 
       	  control model restart but it also has corrected temperatures of 
       	  the ocean which were not used in the control run. These
       	  temperatures are the temperature between the mixed layer and the 
       	  annual maximal mixed layer depths (TOCEAN(2,im,jm)) and the 
       	  temperature at annual maximal mixed layer depth (TOCEAN(3,im,jm)).
       	  You have to specify AIC=IMJAN.RunIDcontrol.O250D in your Q-flux 
       	  run-deck. You have to move this file to /u/cmrun directory as well. 
       	    
       In your Q-flux model run-decks, you have to 
       	  (1) specify KOCEAN=1; 
       	  (2) make sure that U00wtr and U00ice are the same as in you 
       	      control run. Then your Q-flux model will be as well balanced 
       	      as your control run. 
       	    
       P.S. In your ../modelE/aux directory you will also get the line-plot
       	    file ohtRunIDcontrol.first_year-last_year.lpl which you can plot 
       	    and compare with observational data if you like. 
       	    You will also get few PRT files which you can remove. And you 
       	    can remove the symbolic link for fort.1. 


   1d: How to set up a Q-flux model with diffusion into a deep ocean
       Such a run needs a preliminary Q-flux model running for 10 years
       in equilibrium, saving (KCOPY=3) the data necessary for diffusion
       computations (see /u/cmrun/model/notes/deep.ocean.doc)

4) HOW-TO stop and restart the GCM

Use the command 'sswB E001xyz' to stop the model run in a controlled
fashion. Restart it with the command 'run E001xyz'.

5) HOW-TO change boundary conditions

6) HOW-TO change trace gas amounts

7) HOW-TO have a perpetual winter

8) HOW-TO travel back/forward in time

9) HOW-TO move to Mars

10) HOW-TO get help or report a problem

There is a mailing list 'giss-gcm-users-l@giss.nasa.gov' where queries,
problems and comments on the gcm can be aired. Sending a message here
is probably more likely to get a quick response than emailing any one
person. 
Subscribe to this by sending a message to Majordomo@giss.nasa.gov with
a line "SUBSCRIBE giss-gcm-users-l" in the body of the text.

12) HOW-TO keep up-to-date

Periodically, we will release new, improved versions of the model
code. You will be notified through the mailing list, and you can
decide whether to upgrade your code, or wait until a more suitable
time. None of your changes will be lost if you upgrade. However, some
conflicts may occur, though they should be minor. Detailed
instructions will be given at the time.

13) HOW-TO add to this documentation

This documentation is part of the model code, and so changes to files
in the modelE/doc directory can be uploaded to the main repository. 
Please contact one of the developers if you have some changes that you
would like to commit. 

Part II: Getting information from the diagnostics

1) HOW-TO analyse the printout
2) HOW-TO change what is included in the printout
3) HOW-TO produce daily/monthly or seasonal diagnostics
3) HOW-TO produce useful diagnostics from the ACC file
4) HOW-TO produce netcdf/hdf output



Part III: The model code

1) HOW-TO find where a variable is defined

Variables (other than purely local variables) are defined in three
main ways. Physical constants (real constants, not tuning parameters),
are defined in const.f, model related variables (i.e. variables to do
with how the model is run) are defined in E001M12_COM.f, and all other
variables are defined in the physics MODULES. Variables that are on
the model grid will be defined in the PHYS_COM module, while
parameters and options for the local physics will be defined in the
PHYS module. Thus decide to which physics module your variable is most
related to and look there.

For more brute force efforts, run the utility 'gcmdoc RUNNAME'. This
will create a html document that indexes and defines all important
variables (well not all, but most, ok some!). Alternatively grep -i
"varname.*=" *.[fSU] will probably find it for you.

2) HOW-TO follow the program structure

The model is essentially on three levels. MAIN in ME001M12 is the
top level and controls the time-stepping and deals with most of the
model overhead. The time-step loop in MAIN is the principal path that
the model follows. This is a very linear loop, and therefore is not
difficult to understand.

The level below this is the level of the drivers. These are routines
that translate model variables (ie. those defined on the model grid),
to local variables (usually, but not always, vertical arrays), save
diagnostics and save variables/fluxes for later use.

Finally the third level is the level at which the actual physics gets
done. This level generally is oblivious to the previous two levels and
is code that could be used in many different contexts. It is very
important to keep this true. DO NOT write directly to model arrays
within a local physics subroutine. (Some outstanding cases may appear
to do that, but this is being written out of the model).

3) HOW-TO use or add to the automatic documentation

You will have noticed that modelE has multiple documentation
directives such as !@var or !@sum. These are key words that can be
read by a script and turned into useful documentation. Each
subroutine, and each important variable should have such a declaration
(which should include a definition, units, etc.). The utility 'gcmdoc'
makes html output from a rundeck containing (and sorting out) all this
information. The various directives are all defined in the main model
common block. If you introduce new variables or subroutines, you MUST
define similar documentation.

4) HOW-TO ensure that your code meets the new standards

Please check the document "Coding standards for ModelE" and try to
conform as nearly as possible to the (not very onerous)
conditions. Unfortunately, we do not have anybody whose job it is to
make sure that added code conforms. However, every time this happens
it makes it harder to keep the model consistent, and leads to the
creation of unnecessary complications in keeping things straight.

5) HOW-TO add functionality - A: variations on existing code


6) HOW-TO add functionality - B: introducing new sub-modules


7) HOW-TO add functionality - C: introducing a new NAMELIST parameter

Only introduce a new NAMELIST parameter if you would like to be able
to vary it's value at run time without recompiling the model (i.e. an
adjustable parameter, or an option switch for instance). Firstly,
decide who should own the parameter. That is likely to be one of the
physics modules. Since it is likely to be a fundamental part of a
local physics process, it should be declared and defined in the local
physics module. You now need to USE it in the physics COM block (this
is to allow the input/output routines to access it easily). In INPUT,
you should then USE this parameter from the COM block. This is a
little indirect but it cuts down on dependencies and is neater. Then
the variable can be added to the NAMELIST. You will probably also need
to add this parameter to the rsf/acc files for future reference - see
Q9 for details.

8) HOW-TO add functionality - D: adding new diagnostics

The diagnostic system that the GCM uses is very sophisticated and is
almost certainly sufficient for any new need for diagnostics that
arises. However, it can seem complex and difficult to use. As
improvements in ease of use occur, it will get easier to modify.

a) Adding a new conservation diagnostic: These arrays keep track of
the zonal average of any quantity, and note which routines change
those values. They are useful in understanding the overall
mass/energy/tracer budgets. To add a new conservation quantity, first
write a routine that returns the zonally averaged quantity in
question. Secondly, in the 'init' subroutine for the relevant physical
module, insert a call to 'SET_CON' this sets up the points at which
the diagnostic is called, and how it is output. (see init_DIAG for
more detailed instructions). Thirdly, you must increase NQUANT by 1,
and KCON by 2+number of points at which you are saving the value.

Other diagnostics will be explained if and when I work them out.

9) HOW-TO read in an external file

ModelE has introduced a FILEMANAGER system that controls the
assignment of unit numbers and the opening of files. To add a new file
to be read in, first define a short mnemonic for the file
(i.e. "TRSRC" for the tracer source file). This is the name
that you will assign in the rundeck to the file you wish to
open. Secondly, prior to reading in the file, use the routine
'getunit' to assign a unit number for the file using the mnemonic you
gave it. ie.

     USE FILEMANAGER
     INTEGER iu_trc1
     ....
     call getunit("TRSRC",iu_trc1,.TRUE.,.TRUE.)
     READ(iu_trc1) DATA1,DATA2....

The first logical variable argument is true if the file is to be
opened for unformatted (binary) read/write, .FALSE. for ASCII
input. The second logical variable denotes whether this is an already
existing file or not. The line in the rundeck should look something
like (depending on the filename of course):

TRSRC=tracer_sources.1970_1980.dat

The setup script looks automatically in /u/cmrun, /u/raid and in the
current directory. If the file is elsewhere an absolute or relative
pathname is needed.

10) HOW-TO add new variables to the restart files

Each module now has only one place that needs to be changed to
accommodate extra variables in the rsf files: io_xyz (where xyz is a
descriptor for the module like ocean, rad, lakes etc.). All
input/output is controlled by these routines. Thus to add a new
variable, simply add it to the list of variables for both the read and
the write statements. Note that you MUST change the MODULE_HEADER
character string if you change what is in the rsf (ie. increment the
number by 1 each time you do this). This is necessary to ensure that
we can distinguish various versions.

There are some complications for variables that can be set in the
NAMELIST, namely, you must decide how this variable gets set as a
function of the initialisation method. Look at io_rad as an example to
follow.

10) HOW-TO access variables that are already calculated somewhere else

One of the main changes to modelE was to replace common blocks with
Fortran 90 modules. The functionality is much the same, but since they
do not assume anything about where in memory variables are kept, many
of the problems associated with common blocks are alleviated. In order
to make use of a variable from somewhere else in the code, that
variable must be in the relevant MODULE (usually called PHYS_COM, for
ease of remembering). Then in the routine of the module where you wish
to use it you must specifically declare what you want using the USE
statement. For clarity, we are insisting upon using 'USE, only' so
that each variable that you require is explicitly declared, ie.

    USE PHYS_COM, only : var1,var2

If the name of the variable conflicts with a local variable, you can
use the 'points-to' feature to map the PHYS_COM variable to a new name
(as you may have done with common blocks), i.e.

    USE PHYS_COM, only : var1,var2_phys=>var2

The arrow should be read as 'points to', and thus var2_phys will be an
alias for var2 in this routine/module only.

12) HOW-TO deal with the inevitable bugs you introduce

Nobody's code is perfect (least of all ours) and so when coding it is
inevitable that errors are introduced. Some are minor and cause no
obvious sign of distress (these are very difficult to find!), while
others cause the model to crash and burn.

Let's say you've changed something in the model that seemed innocuous,
and then the model crashes. There are three common points that seem to
trap errors: the dynamics, the radiation and the PBL scheme. These
errors will be flagged as either "A>1 in AADVTX" or similar (for
crashes in the dynamics), "In Radia: TL out of range" or similar (in
the radiation), and finally a "stop rtsafe", for a
crash in the PBL.

Do not go looking for errors in any of these routines. What has
generally happened is that you have introduced some wild fluctuation
in some main variable (the temperature, humidity or velocities), or
overwritten some the model variables that control advection and the
like. Check that coming out of the routine you modified, everything is
as it should be (set QCHECK in the rundeck, and include a call to
CHECKT immediately before and after). Also do not bother commenting
out the routine that actually crashed to see if the model can continue
on okay. This routine is the symptom, not the disease.

One additional problem that arises mainly with tracer code is that the
advection code can sometimes produce wild oscillations of the tracer
concentration, which for sensitive tracer physics, can cause no end of
problems. Again, the advection is not to blame! What has happened here
is that the second order moments for the tracer field (the first and
second derivatives at the centre of the grid-box) have somehow become
uncoupled from the mean tracer amount, giving rise to an implied
sub-grid scale profile that is seriously wrong. The biggest mistake is
not to reduce the gradients by the same fraction by which the mean was
reduced in some process. See the document "Using the GISS GCM tracer
moments" for more details on how to do this properly. The CLD01.f
tracer code is a good example of what to do.

13) HOW-TO get an innovation included in everybody's versions

Since you are working on the code within CVS, it is possible to upload
your changes to the main development branch. However, this is highly
unrecommended for the average user, and so I am not going to tell you
how to do it! Instead, please discuss it with one of the development
team. If you wish to make a lot of changes and be part of the ongoing
development of modelE, then please read the file
http://www.giss.nasa.gov/~gavin/gcm_develop.html and then come and
talk to me (gavin@giss.nasa.gov). 
