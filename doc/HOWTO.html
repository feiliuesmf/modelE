<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<body bgcolor="#ffffff" text="#000000" link="#000099" vlink="#cc0000" alink="#cc0000">
<HEAD>
 <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
 <TITLE>HOW-TO document for the GISS GCM</TITLE>
</HEAD>
<BODY>
<H1>HOW-TO document for the GISS GCM</H1>

<P>
This document outlines how to achieve some commonly sought results with
the new modelE. Some of the procedures will be the same as previously,
but it is more likely that the details will have become slightly more
straightforward (hopefully!). However, due to the modularization that
has been done, you are no longer free to do things in an arbitrary
way, see the notes below for more details. Please feel free to add to
this document.</P>

<P>This is only part of the documentation, you can find additional
information in the glossary of terms (not yet available), the
<a href="FAQ.html">Frequently Asked Questions (FAQ) file</a>, the
description of current functionality and
<a href="OPTIONS.html">options</a>, or the index of all
prognostic variables (determined using 'gmake htmldoc' (see
<a href="#part3_1">below</a>).</P>

<P>The document is set up in four parts: Part 0 deals with getting the
code, Part I deals with running the model for basic users who do not
need to know how to alter the code. Part II dealing with examining the
diagnostics, while Part III deals with more technical issues involved
in adding functionality or diagnostics.</P>

<P><A HREF="#part0">PART 0: Getting the code</A></P>

<P><A HREF="#part1">PART I: Basic user information</A></P>
<OL>
  <LI><A HREF="#part1_1"> HOW-TO setup and run the GISS GCM</A>
     <OL>
       <LI> <A HREF="#part1_1a"> How to select a rundeck name </A>
       <LI> <A HREF="#part1_1b"> How to interact with CVS to make sure
     the run is reproducible</A>
     </OL>
  <LI><A HREF="#part1_2"> HOW-TO set rundeck parameters</A>
     <OL>
       <LI> <A HREF="#part1_2a"> How to tune a specified ocean run
     (using U00wtr) </A>
       <LI> <A HREF="#part1_2b"> How to set up a Q-flux model with a
     single ocean layer </A>
       <LI> <A HREF="#part1_2c"> How to set up a Q-flux model with
     diffusion into a deep ocean </A>
       <LI> <A HREF="#part1_2d"> How to use them to control numerical
     instabilities </A>
       <LI> <A HREF="#part1_2e"> How to use IRANDI to create an
     ensemble of runs </A>
     </OL>
  <LI> <A HREF="#part1_3"> HOW-TO stop and restart the GCM</A>
  <LI> <A HREF="#part1_4"> HOW-TO change boundary conditions</A>
       <OL>
	 <LI> <A HREF="#part1_4a"> HOW-TO alter the topography file
	      consistently</A>
       </OL>
  <LI> <A HREF="#part1_5"> HOW-TO change trace gas amounts</A>
  <LI> <A HREF="#part1_6"> HOW-TO have a perpetual winter</A>
  <LI> <A HREF="#part1_7"> HOW-TO travel back/forward in time</A>
  <LI> <A HREF="#part1_8"> HOW-TO move to Mars</A>
  <LI> <A HREF="#part1_9"> HOW-TO move to Wonderland</A>
  <LI> <A HREF="#part1_10"> HOW-TO report a problem</A>
  <LI> <A HREF="#part1_11"> HOW-TO keep up-to-date</A>
  <LI> <A HREF="#part1_12"> HOW-TO move the model offsite</A>
  <LI> <A HREF="#part1_13"> HOW-TO add to this documentation</A>
</OL>
<P><A HREF="#part2">Part II: Getting information from the
diagnostics</A></P>
<OL>
<LI><A HREF="#part2_1"> HOW-TO look at the output</A>
<LI><A HREF="#part2_2"> HOW-TO change what is included in the
     printout</A>
<LI><A HREF="#part2_3"> HOW-TO produce daily/monthly or seasonal
     diagnostics</A>
<LI><A HREF="#part2_4"> HOW-TO control the format of the binary output
     (i.e. GISS/netcdf/hdf etc.)</A>
</OL>

<P><A HREF="#part3">Part III: The model code</A></P>
<OL>
  <LI><A HREF="#part3_1"> HOW-TO find where a variable is defined</A>
  <LI><A HREF="#part3_2"> HOW-TO follow the program structure</A>
  <LI><A HREF="#part3_3"> HOW-TO use or add to the automatic
       documentation</A>
  <LI><A HREF="#part3_4"> HOW-TO ensure that your code meets the new
       standards</A> 
  <LI><A HREF="#part3_5"> HOW-TO add functionality</A> 
       <ul>
	 <li><A HREF="#part3_5a"> A: Variations on existing code</A>
	 <LI><A HREF="#part3_5b"> B: Introducing new sub-modules</A> 
	 <LI><A HREF="#part3_5c"> C: Introducing a new parameter</A> 
	 <LI><A HREF="#part3_5d"> D: Adding new diagnostics</A>
	 <LI><A HREF="#part3_5e"> E: Adding extra timing information</A>
       </ul>
  <LI><A HREF="#part3_9"> HOW-TO read in an external file</A> 
  <LI><A HREF="#part3_10"> HOW-TO add new variables to the restart
       files</A>
  <LI><A HREF="#part3_11"> HOW-TO access variables that are already
       calculated somewhere else</A>
  <LI><A HREF="#part3_12"> HOW-TO deal with the inevitable bugs you
       introduce</A>
  <LI><A HREF="#part3_13"> HOW-TO deal with restart problems
       (non-reproducibility of results)</A>
  <LI><A HREF="#part3_14"> HOW-TO get an innovation included in
       everybody's versions</A>
</OL>

<P>Finally, CREDITS where CREDITS are due:
<UL>
  <LI>For ongoing development (who to blame for the current shambles):<BR>
       Gavin Schmidt, Reto Ruedy, Jean Lerner, Max Kelley,
       Igor Aleinov, Gary Russell, Ye Cheng, Andy Lacis,
       M. S. Yao.
  <LI>Historical development (stuff we haven't rewritten yet):<BR>
       Bob Suozzo, Suki Sheth, Hans-Peter Zinn, Rick Healy,
       Frank Abramopoulos, Greg Hartke
  <LI>Inspiration (the people paying for this):<BR>
       David Rind, Jim Hansen, Tony Del Genio
</UL>

<hr>

<h3><A name="part0">Part 0: Getting the code</A></h3>

<p>The modelE code including source code, scripts and some documentation.
This is stored through the CVS revision control system, and copies can
be checked-out to your home directory using the following commands:</p>
<tt>
   export CVSROOT=/u/cmrun/cvs/repository<br>
   cvs checkout -r modelE-1-0 modelE<br>
   cd modelE<br>
   cvs tag -b your_tag_here<br>
   cvs update -r your_tag_here<br>
</tt>

<p>This will create a directory modelE/ in your directory. The code will
correspond to modelE-1-0 - the first release. It will be tagged with your
own tag name so that your developments can be maintained by CVS, without
conflicting with the main development branch.</P>

<p>Please subscribe to the mailing list 'giss-gcm-users-l@giss.nasa.gov'
by sending a message to Majordomo@giss.nasa.gov with a line</P>

<tt>SUBSCRIBE giss-gcm-users-l</tt>

<p>in the body of the text. This is to ensure that you are notified of
bug fixes and new releases. Also this is a forum for you to ask
questions about the model.</p>

<hr>

<h3><A name="part1">Part I: Basic user tasks</a></h3>

<p><A name="part1_1"><b>1) HOW-TO setup and run the GISS GCM</b></a></p>

In order to run the GCM a 'rundeck' file (with a suffix .R) must be
created. This contains information about the run you would like to
perform, the fortran code that you intend to use, pre-processing
options that are required, the boundary and initial conditions and any
run-specific parameters (such as the time step, length of run
etc.). Most of the specifics have been automated using 'gmake'.

The sub-directory 'decks' is the main control directory, most commands
will be issued in this directory. Typing 'gmake' will produce some
documentation.

There are five sample rundecks: E001.R, E001A.R, E001B.R., E001D.R and
E001M23.R. These represent a standard fixed SST atmosphere only run, a
Qflux run, a coupled ocean-atmosphere run, a Qflux with deep diffusion
run and a stratospheric model run, respectively.

<OL>
   <LI> <A name="part1_1a"><b> How to select a rundeck name </b></A>

<p>In order to make a rundeck that you can use and modify, you must
first select a unique name for your run. There is a central database
for storing user's rundecks (along with other pertinent information
such as the time of compilation, the compiler version, and the current
CVS branch) in <tt>ra:/u/cmrun/modelE/decks</tt>. This allows us to
automatically tell whether a rundeck name has already been
used. However, in order to minimise any confusion, we propose the
following naming convention: </p>
 <ul>
 <li> Each rundeck should start with 'E' (to distinguish it
             from other models in the building)
 <li> The next three characters should be a counter (starting
             at '001') which the individual user will update as they perform
             successive runs.
        <li> The next part consists of the users initials (or other
             unique identifier.
 <li> If the user is experimenting with variable resolutions,
             it may be helpful to add 'M12' or 'M23' or 'F32' etc. to
             the end of the name to distinguish between the Medium
             resolution 12 or 23 layer model, or the Fine resolution,
             32 layer model etc.
 </ul>

<p> <em>Note that this implies that there would be not necessarily be any
connection between runs E034xxx and E034yyy, since the numbers now
refer to the run sequence, rather than the model version sequence.</em></p>

<p> Once a rundeck name has been chosen (for example E001xyz), the
rundeck will be created using

<pre>
     gmake rundeck RUN=E001xyz
</pre>

This will make a rundeck E001xyz.R, that will be a copy of E001.R. To
make a copy based on another of the sample decks, use, for instance,
<pre>
     gmake rundeck RUN=E001xyz RUNSRC=E001A
</pre>

A copy of the new rundeck will be stored in the rundeck depository on
ra. If there is a clash with an existing rundeck name (including
perhaps one of your previous runs), there will be an error message. If
you want to insist on overwriting a previous version say, then give
the command
<pre>
     gmake rundeck RUN=E001xyz OVERWRITE=YES
</pre>
If you create a rundeck in any other fashion, ie. by directly copying
one. There is no chance to verify its uniqueness. However, a secondary
check is made when you attempt a 'setup' (see below) which should
catch any inadvertent duplication. </p>

<p>
The list of fortran files within the rundeck determines which files
are compiled into the executable. The compilation is automatic, and
will take account of all dependencies, so that if a file is modified
it will be re-compiled, along with any files that directly or
indirectly depend on modules or routines within it. The executable is
made using
<pre>
     gmake gcm RUN=E001xyz
</pre>
To actually run the model, you must first 'setup' the run by running
the first hour (or specifically the first source time step).
<pre>
    gmake setup RUN=E001xyz
</pre>

If this runs successfully there will be a message saying so. Likewise
if there is a problem.</p>

   <LI> <A name="part1_1b"><b> How to interact with CVS to make sure
     the run is reproducible</b></A>
<p>

It is of some importance that runs be reproducible, either by other
people, or later on by the users themselves. With version control now
using the CVS system, it implies that CVS <B> MUST </B> know about any
code variations that make it into any production run (i.e. one that is
not simply a compilation test or debugging). We know that test runs
and production runs are not necessarily easily distinguishable a
priori (i.e. a run is a test run until it works, at which point it
retroactively turned out to be the production run).  So the best way
to ensure thats the relevant information is saved is through frequent
'commits' to the cvs repository of all substantial changes you make to
the code. By this we mean at minimum all changes that have effects on
the prognostic variables (as opposed to diagnostic printout).  </P>

<p> There is no cost to this procedure (although you should be careful
to ensure that code at least compiles before any commits are made.) </p>

<p> At the 'setup' stage (or at the 'exe' stage if you are recreating
an executable files) further information is added to the rundeck
depository indicating any changes to the rundeck since it was made,
along with full CVS information on what was actually compiled. To
retrieve this exact code, it is sufficient to know the time the run
was compiled, and the CVS branch that the user was on.</p>

 </ol>

<p> Once a successful 'setup' is done, use the command
<pre>
  run E001xyz
</pre>
to set the model running for the specified length of the run.</p>

<p> If you need to stop the run at any point, use the 'ssw E001xyz'
command to do it in a controlled fashion (ensuring that all variables
are saved correctly, and that no printout gets stuck in a
buffer). using 'run E001xyz' subsequently picks up from where you left
off. </p>

<p> If you would like to update the executable (putting in new
printout, or fixing an error etc.) without starting from 'setup' all
over again, you can use
<pre>
  gmake exe RUN=E001xyz
</pre>
which will recompile the fortran, and replace the executable file in
the run directory. Then 'run E001xyz' will pick up from where you
stopped previously, but with the new code. Any changes to the CVS
information between the initial setup and the new code will be
recorded in the central rundeck repository.</p>

<p><A name="part1_2"><b>2) HOW-TO set rundeck parameters</b></a></p>

    There are 2 types of parameters that may be set in the rundeck:
    DATA BASE (dp) parameters and NAME LIST (nl) parameters
    The dp-params are set between &amp;&amp;PARAMETERS and &amp;&amp;END_PARAMETERS
    The nl-params are set between  &amp;INPUTZ     and  &amp;END

    The dp-params are saved in record 3 of the save files (acc,rsf)
       They are tuning or control parameters.
    the nl-params are saved in record 1 (ISTART,IRANDI,IYEAR1) or
       not at all (all others). These others set start and stop
       date for the run: (YEAR/MONTH/DATE/HOUR)I or E or IHOURE
       or determine the (debug) printout: KDIAG,IWRITE,...,QCHECK

    When a run starts, parameters not set in the rundeck take their
    default values. On restarts, YEAR/MONTH/DATE/HOURI are ignored;
    all other parameters are determined first by the rundeck, then
    by the restart file if they were saved, else use the defaults.
    So the priorities are: 1. rundeck, 2. restart file, 3. defaults.

    To start a run, the following parameters HAVE to be explicitly
    set: ISTART=2 | 7 or 8 to start from obs | model Initial State
         YEARI    = year in which model starts
         YEARE (or IHOURE) = year (or hour) at which model stops

    To change parameters after a run was started, do the following:
         1:    edit the file 'I' in the run directory,
         2:    stop and restart the run,
         3:    re-edit I to ready it for the next restart
       (If the change affects the results, attach a log of all such
        changes to the end of the rundeck)

       For a list and explanation of all parameters see
          /u/exec/docE/params.txt.

<p><A name="part1_2a"><b>A: How to TUNE a specified ocean run (using
U00wtr)</b></a></p>
<P>    It is desirable to run a specified ocean model in such a way that
       it is in RADIATIVE BALANCE, i.e. that the net flux of energy into
       the ocean (which has no effect, since ocean data are specified)
       is zero if averaged over a whole year. One way to roughly achieve
       this goal is to pick the right value for U00wtr. That parameter
       influences the cloud formation where the temperature is above 0C
       and can therefore be used to change the radiative balance.</p>

<p>    Run the model for a year and find the annual mean net heating at
       the ground (budget page). That quantity may change from year to
       year within .5 W/m2 . Increasing U00wtr by .01 increases that
       quantity by about .3 W/m2 . Rerun that year with a new value of
       U00wtr hoping that the annual mean net heating at the ground
       averages out to less than .3 W/m2 in absolute value over the next
       few years.</P>

<p>    Increasing U00ice works in the opposite direction but changes
       the global cloud cover considerably. It could be used to tune
       the cloud cover (before picking the final U00wtr).</P>

<p>    Other ways to handle the rad. balance problem: Change the solar
       constant until rad. balance results (most people hate that way),
       change the solar irradiance into the ocean when running the
       Qflux model (using the old SRCOR parameter) offsetting the
       imbalance (advantage: no need to repeat the control run,
       disadvantage: Jim hated it, no longer part of the code).</p>

<p><A name="part1_2b"><b>B: How to set up a Q-flux model with a single
ocean layer</b></a></p>

<p>    A preliminary run with prescribed climatological ocean has to
       be run for about 6 years collecting daily fluxes into the ocean
       (Kvflxo=1). Based on these data, a new input file (OTSPEC...)
       has to be created that specifies the horizontal heat transports
       in the ocean; in addition, the ocean temperatures at the annual
       maximum mixed layer depth and the mean temperature between that
       level and the bottom of the current mixed layer depth have to be
       computed for the final time of the preliminary run and added to
       the final restart file of that preliminary run. That augmented
       restart file will serve as initial state file for the new run.
       During the first few years, monitor the time series of global
       annual means of  Ocean Ice Cover  and  Surface Air Temperature.
       Hopefully, they will no longer change after a few years (10-25).
       The model is said to be in balance as soon as that happens.</p>

<p>    To run the Q-flux model it is necessary to supply the implied
       horizontal heat transports and proper initial condition as
       input files. To calculate the horizontal ocean heat transports
       it is necessary to run the model with prescribed ocean mixed
       layer temperature and sea ice extent for 5-6 years. It is
       desirable to have this control run well balanced (Net Heat at
       z0 is supposed to be close to 0 for annual mean. This Net
       Heat at z0 can be found on the first budget page for the global
       quantities. To get the balanced control run, you can adjust
       U00wtr (see 1b). In your control run-decks, you have to have
       Kvflxo=1. Then the model will save the data for the heat
       transport.</P>

<p>    For the ocean heat transport calculation, it is necessary to
       skip the first year of this control run because of the spin-up
       of the atmosphere. For this calculation you need to do next
       (suppose your control run is RunIDcontrol):</p>
<ol>
  <li> Go to the ../decks directory and do
       gmake auxqflux RUN=RunIDcontrol. This will create executables
       for the ocean heat transport calculation and it will put
       them to the directory ../modelE/decks/RunIDcontrol_bin.

  <li> Go to the ../aux directory and run the script
<pre>
    mkOTSPEC.E001.M250D RunIDcontrol first_month first_year last_month last_year
</pre>
      where months and years are integers and span the months
      that you wish to be used for the heat transport calculation.
      Usually first_month=1, first_year=1951, last_month=12,
      last_year=1955 if your control model went for 6 years
      starting Jan.1 1950. Note that the surface heat imbalance number
      is the ratio of the incoming energy to the outgoing. A number
      less than one denotes a net heating of the ocean. If the number is
      with 1% of unity, there is no need to worry.

<li> After this you will get two files (in the original
run directory) which you will use as input data for your Q-flux
model:
       <ol>
       <li> <tt>OTSPEC.RunIDcontrol.M250D.first_year-last_year</tt>
          This file is the implied ocean heat transport data. In your
          Q-flux run-deck the input file OHT has to have this name, in
          other words OHT=OTSPEC.RunIDcontrol.M250D.first_year-last_year.
          You should move this file to /u/cmrun directory.
       <li> <tt>IMJAN.RunIDcontrol.O250D </tt> is the modified restart for the
          Q-flux model. This restart is basically is the same restart as your
          control model restart but it also has corrected temperatures of
          the ocean which were not used in the control run. These
          temperatures are the temperature between the mixed layer and the
          annual maximal mixed layer depths (TOCEAN(2,im,jm)) and the
          temperature at annual maximal mixed layer depth (TOCEAN(3,im,jm)).
          You have to specify AIC=IMJAN.RunIDcontrol.O250D in your Q-flux
          run-deck. You have to move this file to /u/cmrun directory as well.
       <LI> In your aux directory you will also get the line-plot
   file <tt>ohtRunIDcontrol.first_year-last_year.lpl </tt>
          which you can plot and compare with observational data if you like.
   You will also get few PRT files which you can remove.
     </ol>
     In your Q-flux model run-decks, you have to
     <ol>
       <LI> specify KOCEAN=1;
       <LI> make sure that U00wtr and U00ice are the same as in you
     control run. Then your Q-flux model will be as well balanced
     as your control run.
       <LI> specify AIC and OHT as described above.
     </ol>
</ol>

<p><A name="part1_2c"><b>C: How to set up a Q-flux model with diffusion
into a deep ocean </b></a></p>
<p>    Such a run needs a preliminary Q-flux model running for 10 years
       in equilibrium, saving (KCOPY=3) the data necessary for diffusion
       computations (see /u/cmrun/model/notes/deep.ocean.doc). A new
       file has to be created ('TG3M' in the rundeck) using 'gmake
       auxdeep RUN=E001xyz' and then running 'mkdeep *.oda.*'. This
       creates the initial conditions and climatology at the base of the
       mixed layer. Use E001D.R as a rundeck template.</p>

<p><A name="part1_2d"><b>D: How to use parameters to control numerical
instabilities</b></a></p>
<p>
       Parameter   affects:                   depends on:<br>
       DT          stability at poles         hor. resolution, AVRX<br>
       NIsurf      stability at the surface   vert.resolution near surf<br>
       XcdLM       stability at the top       model top pressure PMTOP<br>
       M/NFILTR    checker board patterns     dynamics scheme<br>
</p>

<p><A name="part1_2e"><b>E: How to use IRANDI to create an ensemble of
runs</b></a></p>
<p>    If ISTART<10 and IRANDI/=0, all atmospheric initial temperatures
       are randomly perturbed by at most 1C . The perturbations depend
       on the value of IRANDI.</P>
<p>    So to create an ensemble of N runs whose only difference is the
       initial state they start up from, pick N (odd) numbers and
       create N copies of the rundeck that only differ in the runID and
       the value set for IRANDI.</p>
<p>    It is good practice to put IRANDI on the same line as ISTART
       so it will not affect later extensions or reruns, since it is
       then automatically removed from the file 'I'.</p>


<p><A name="part1_3"><b>3) HOW-TO stop and restart the GCM</b></a></p>

<p>Use the command 'ssw E001xyz' to stop the model run in a controlled
fashion. Restart it with the command 'run E001xyz'. If you would like
the run-time printout to be suppressed (to save filespace) use the
command 'runn E001xyz'. The monthly/seasonal/annual printout can
always be recreated if needed.</p>

<p><A name="part1_4"><b>4) HOW-TO change boundary conditions</b></a></p>

<p>Simply alter the file declarations in the rundeck appropriately!</p>

<ol>
  <li><A name="part1_4a"><b>a) HOW-TO alter the topography file
       consistently</b></a> 
       <p> The topography file (TOPO) in the rundeck, must have a
       degree of internal consistency. Therefore if changes are made
       to the ocean mask (FOCEAN), for instance, other changes are
       required for the other fields (FLAKE,FEARTH,FLAND,FLICE). In
       particular: 
       <pre>
       IF (FOCEAN(I,J).gt.0) THEN
         FLAKE(I,J)=0.   ! lake and ocean cannot co-exist at the same grid point
         FLAND(I,J)=1.-FOCEAN(I,J) 
       END IF
       IF (FLAKE(I,J).gt.0) FLAND(I,J)=1.-FLAKE(I,J) 
       IF (FLICE(I,J).gt.FLAND(I,J)) THEN
         FLICE(I,J)=FLAND(I,J)  ! land ice fraction takes precedence over earth
         FEARTH(I,J)=0.
       ELSE
         FEARTH(I,J)=FLAND(I,J)-FLICE(I,J)  ! earth is a residual
       END IF
       </pre>
       If land boxes are added close to the Antarctica or Greenland
       ice sheets, FLICE should be set to FLAND, FEARTH to zero. Note
       as well that the polar boxes must be homogenous
       (i.e. FOCEAN(2:IM,JM)=FOCEAN(1,JM) etc.)  </p>
       
       <p>Some other external file data may not be consistent with the
       new land/ocean mask but the model code will extrapolate from a 
       nearest neighbour to fill those points in.</p>
</ol>

<p><A name="part1_5"><b>5) HOW-TO change trace gas amounts</b></a></p>

<p>This is not as obvious as it should be:
<ol>
<li> CO2 levels can be set simply from the rundeck. Setting CO2=3 for
instance will give CO2 level three times as high as the default (which
is the CO2 level on July 1, 1981 = 311.098). Setting CO2 to be a
negative integer, will allow the CO2 to vary according to a number of
different scenarios (i.e. observations until 1998, various projections
subsequently).

<li> Other gases are slightly more problematic, although we are working
on that. Essentially they should be able to be adjusted using the
'FULGAS' array in init_RAD in a similar way to CO2. Stratospheric
water vapour is more complicated and requires hacking about in the
radiation code. Not recommended for the novice.
</ol>

<p><A name="part1_6"><b>6) HOW-TO have a perpetual winter</b></a></p>

<p>Orbital parameters must be fixed and so 'ORBIT' in DAILY should be
given the same JDAY every day. (i.e. JDAY0=1 for JAN 1st conditions).
Though this will have consequences for the polar regions (since there
will be no seasonality there). Possibly there is another way....</p>

<p><A name="part1_7"><b>7) HOW-TO travel back/forward in time</b></a></p>

<p>A number of things can change depending on the time period concerned.

<ol>
  <li> orbital parameters. Change these in CONST.f (note LGM and 6K BP
       versions will soon be made available).
  <li> trace gas amounts. (see Q6) Note that for really large changes,
       the mean atmospheric composition will change (and thus so will RVAP
       etc. See CONST.f for details)
  <li> continental configuration. Change the boundary condition files
       in the run deck. (Also for land use/cover changes, ice sheets etc.)
  <li> Mean atmospheric pressure. Change PSF etc. in the RES_xyz file.
  <li> Speed of rotation. A little tricky since this effects OMEGA (in
       CONST.f) but also SDAY, and depending on how you define an 'hour', the
       number of seconds in an hour, or the number of hours in the
       day. Remember that dtsrc must divide into sday exactly.
  <li> Solar constant. This can be set by the multiplicative factor S0X
       within RAD_DRV.f (I think)
  <li> Aerosol/dust amounts. These can be changed within RAD_DRV.f or by
       changing the RADN input files.
</ol>

<p><A name="part1_8"><b>8) HOW-TO move to Mars</b></a></p>

<p>Like travelling back in time, only more complicated. Oh, and no water.
Note that the length of year is set by EDPERY in CONST.f. </p>

<p><A name="part1_9"><b>9) HOW-TO move to Wonderland</b></a></p>

<p>The wonderland model is a sector version of the GCM that is used for
very fast or very long runs that do not have to be as true to the real
climate as normal. Essentially, the globe is split into three sectors,
and only one sector is prognostically calculated. You must alter the
resolution (IM will be 24), change the definition of DLON (in
GEOM_B.f), and make sure that the radaition calculation has been
modified to synchronise the diurnal cycle over the sector. Note that
this has never been tested.</p>

<p><A name="part1_10"><b>10) HOW-TO get help or report a problem</b></a></p>

<p>There is a mailing list 'giss-gcm-users-l@giss.nasa.gov' where queries,
problems and comments on the gcm can be aired. Sending a message here
is probably more likely to get a quick response than emailing any one
person.</p>

<p>Subscribe to this by sending a message to Majordomo@giss.nasa.gov with
a line "SUBSCRIBE giss-gcm-users-l" in the body of the text.</p>

<p><A name="part1_11"><b>11) HOW-TO keep up-to-date</b></a></p>

<p>Periodically, we will release new, and hopefully improved versions of
the model code. You will be notified through the mailing list, and you
can decide whether to upgrade your code, or wait until a more suitable
time. None of your changes will be lost if you upgrade. However, some
conflicts may occur, though they should be minor. Detailed
instructions will be given at the time.</p>

<p><A name="part1_12"><b>12) HOW-TO move the model offsite</b></a></p>

<p>The model code itself is self-contained. Thus it should be
transportable offsite. However, certain scripts contain references to
central directories on Ra or the other GISS machines, though we are
working to increase their portability. Notably, the 'setup_e' script,
and the location of the 'central rundeck repository' outlined in the
Makefiles. These will have to edited.  Of course, the input data files
are not part of the release, and will need to be downloaded
separately. Some utilities used by 'setup_e' are likewise local and
should either be commented out or adjusted for the local situation.</P>

<p>The biggest problem will be if the machine you wish to run the code
on has a different fortran compiler. Some variation has been fully
allowed for (i.e. the standard SGI or IBM compilers) and some attempts
have been made to accomodate the DEC version or a couple of Linux
compilers, however, we do not have a stable test bed for these and
therefore cannot guarantee they will work.</P>

<p>General problems will arise due to arbitrary compiler decisions on
what to name compiled module files (which affects the determination of
the inter-routine dependencies). Edit model/Rules.make to fix this.
The code is compilable without using the 'static' option, which
removes many of the problems that used to occur. Most of the compiler
dependent code (that we have discovered) can be found in the versions
of RANDxyz.f. These involve system calls to the CPU clock, the
calculation of pseudo-random numbers, and the setting of exit
codes. We would be very interested in further compiler dependencies if
found.</p>

<p><A name="part1_13"><b>13) HOW-TO add to this documentation</b></a></p>

<p>This documentation is part of the model code, and so changes to files
in the modelE/doc directory can be uploaded to the main repository.
Please contact one of the developers if you have some changes that you
would like to commit.</p>

<hr>

<h3><A name="part2"><b>Part II: Getting information from the
diagnostics</b></a></h3>

<p><A name="part2_1"><b>1) HOW-TO look at the output</b></a></p>

<p>You can look at the output in two distinct ways: using the run-time
printout, or using the post-processing program, pDE.</p>
<ol>
  <li> <p>The run-time printout.</p>

       <p>If you run the model using 'run' (as opposed to 'runn' which
suppresses the printout) the model will produce a $RUNID.PRT file
which can contain copious amounts of diagnostic information. It is
split into a number of sections: (see next question for a list). This
is produced each month (but can be contrlled using the KDIAG switches
and NMONAV in the NAMELIST).</p>

  <li> <p>Post-processed output:</p>
       <p>Each month the program produces an 'acc' accumulated
       diagnostics file which contains all of the diagnostic information from
       the previous month. The program 'pDE' (in the exec directory) is an
       alternate entry point into the model that reads in any number of these
       files and a) creates a printout (as above) for the time period
       concerned and b) creates binary output of many more diagnostics. This
       can be used simply to recreate the monthly printout, but also to
       create longer term means (annual, seasonal, monthly climatologies
       etc.).</p>

       <p>For example, to recreate the printout;
       <ul>
  <li>for a single month: pdE JAN1987.acc.$RUNID
  <li>for all Januaries:  pdE JAN*.acc.$RUNID
  <li>for a whole year:   pdE *1987.acc.$RUNID
       </ul>
</ol>
<p>Note that the output can be controlled (a little) by the settings in
'Ipd' (which is produced in the run directory the first time you run
pdE). A number of files will be created appropriate for the
accumulated time period.  (xxxnnnn where xxx is a month or a season or
ANN or DCD, and nnnn is a year or nrange of years).</p>
<pre>
 xxxnnnn.PRT     the printout
        xxxnnnn.j$RUNID zonal budget pages (ASCII Aplot format)
        xxxnnnn.jk$RUNID latitude-height binary file
        xxxnnnn.il$RUNID longitude-height binary file
        xxxnnnn.ij$RUNID lat-lon binary file
</pre>
<p>which can be read using the appropriate graphical software. </p>

<p><A name="part2_2"><b>2) HOW-TO change what is included in the printout</b></a></p>

<p>The switches KDIAG which are set in the NAMELIST control which
subgroups of diagnostics are calculated and output. At present, there
is no simple way to pick and choose exactly which diagnostics appear,
although we are working on a scheme to do just that. Some of the
following options are rarely used, and may soon be made obsolete.
These switches can also be used in 'Ipd' input for pdE to control
which binary output to produce.</p>

<p>Current options are:
<pre>
KDIAG(1)  < 9 print Zonal/Regional budget pages
   = 8 only print regional diagnostics
   2-7 only print global zonal means
   = 1 print all zonal diagnostics

KDIAG(2)  < 9 print Latitude-height diagnostics
          = 8 Only print spectral analysis of standing eddies

KDIAG(3)  = 0 standard printout, all binary files if QCHECK=.true.
          = 1 ij-fields as in list Iij, all ijk-fields
          = 2 ij and ijk fields are handled according to list Iij
          = 7 ij-fields as in list Iij, no ijk-fields are produced
          = 8 full list Iij of available fields is produced; this list may
              be edited : don't touch lines starting with 'List' or 'list'
                          you may delete any other lines
                          you may rearrange the remaining ij-fields
                          you may add blank maplets
          = 9 no ij and ijk diagnostics are produced
          3-6 same as 2

KDIAG(4)  < 9 print time history table of energies
KDIAG(5)  < 9 print spectral analysis tables

KDIAG(6)  < 9 print diurnal cycle diagnostics at selected points (up to 4)
          1-4 print out for first 4-KDIAG(6) points (will soon be obsolete)
        -1 - -4 print out for -KDIAG(6) point only.

KDIAG(7)  < 9 print wave power tables

KDIAG(9)  < 9 print out conservation diagnostics
KDIAG(10) < 9 print out Longitude-height diagnostics
KDIAG(11) < 9 print out river runoff diagnostics
KDIAG(12) < 9 print out ocean diagnostics (if there is an ocean)
</pre>

<p><A name="part2_3"><b>3) HOW-TO produce daily/monthly or seasonal
diagnostics</b></a></p>

<p>Controlling the frequency of output of the ACC files is done using the
NAMELIST parameter NMONAV. This sets the number of months over which
the diagnostics is accumulated. If it is set to 3, seasonal acc files
are produced. If set to 12, you will get annual means. Higher numbers
could be chosen, but are probably not very useful.</p>

<p>Producing more frequent diagnostics is a little more problematic. We
intend to provide the facility to output a limited number of
instantaneous or averaged standard fields (T,Q,U,V,GZ,SLP) at 1,3,6,12
or 24 hourly intervals. But currently, only instantaneous SLP is
available. The hourly frequency is set by NSLP in the parameter list.</p>

<p>You can however easily keep track of the running average of all the
printout diagnostics using the NIPRNT switch in the parameter
database. By setting this to a positive number, the diagnostics will
be printed out that number of days. (i.e. setting NIPRNT=10, will
print out the running average of the accumulated diagnostics at the
end of each of the next ten days).</p>

<p><A name="part2_4"><b>4) HOW-TO control the format of the binary output
(i.e. GISS/netcdf/hdf etc.)</b></a></p>

<p>The binary output created from 'pdE' can be in a number of
formats. Currently there are two options, the traditional GISS
formats, and netcdf output. This is set by choosing to compile the
model with POUT (for GISS-style output) or POUT_netcdf (for netcdf
output). This is set in the rundeck. Note that the choice is made AT
THE TIME OF COMPILATION OF THE MODEL EXECTUABLE. If you subsequently
change your mind, you must edit the rundeck and recreate the
executable (using 'gmake exe RUN=E001xyz').</p>

<p>Other formats can be defined as you like with a suitable POUT_xyz.f
file.</p>

<hr>
<h3><A name="part3"><b>Part III: The model code</b></a></h3>

<p><A name="part3_1"><b>1) HOW-TO find where a variable is defined</b></a></p>

<p>Variables (other than purely local variables) are defined in three
main ways. Physical constants (real constants, not tuning parameters),
are defined in const.f, model related variables (i.e. variables to do
with how the model is run) are defined in MODEL_COM.f, and all other
variables are defined in the physics MODULES. Variables that are on
the model grid will be defined in the PHYS_COM module, while
parameters and options for the local physics will be defined in the
PHYS module. Thus decide to which physics module your variable is most
related to and look there.</p>

<p>For more brute force efforts, run the command 'gmake htmldoc
RUN=RUNNAME'. This will create a html document that indexes and
defines all important variables (well not all, but most, ok
some!). Alternatively grep -i "varname.*=" *.[fSU] will probably find
it for you.</p>

<p><A name="part3_2"><b>2) HOW-TO follow the program structure</b></a></p>

<p>The model is essentially on three levels. MAIN in MODELE.f is the
top level and controls the time-stepping and deals with most of the
model overhead. The time-step loop in MAIN is the principal path that
the model follows. This is a very linear loop, and therefore is not
difficult to understand.</p>

<p>The level below this is the level of the drivers. These are routines
that translate model variables (ie. those defined on the model grid),
to local variables (usually, but not always, vertical arrays), save
diagnostics and save variables/fluxes for later use.</p>

<p>Finally the third level is the level at which the actual physics gets
done. This level generally is oblivious to the previous two levels and
is code that could be used in many different contexts. It is very
important to keep this true. DO NOT write directly to model arrays
within a local physics subroutine. (Some outstanding cases may appear
to do that, but this is being written out of the model).</p>

<p><A name="part3_3"><b>3) HOW-TO use or add to the automatic
documentation</b></a></p>

<p>You will have noticed that modelE has multiple documentation
directives such as !@var or !@sum. These are key words that can be
read by a script and turned into useful documentation. Each
subroutine, and each important variable should have such a declaration
(which should include a definition, units, etc.). The command 'gmake htmldoc'
makes html output from a rundeck containing (and sorting out) all this
information. The various directives are all defined in the main model
common block. If you introduce new variables or subroutines, you MUST
define similar documentation.</p>

<p>Currently defined keywords and syntax are:</P>
<pre>
@sum     UNITNAME Brief summary/description of the current program unit or file
@auth    Author
@ver     Version (a number plus any relevant comments)
@calls   List of routines called in this program unit
@cont    List of program units contained within a file or module + other info.
@fun     FUNCNAME Denotes a function
@param   PARAMNAME Denotes a parameter (in the FORTRAN sense)
@var     VARNAME Denotes a variable (in the FORTRAN sense)
@dbparam VARNAME Denotes a database parameter (in the modelE sense)
@nlparam VARNAME Denotes a NAMELIST parameter (in the modelE sense)
@+       Continuation line for @sum/@calls/@cont
</pre>

<p><A name="part3_4"><b>4) HOW-TO ensure that your code meets the new
standards</b></a></p>

<p>Please check the document
<a href="http://www.giss.nasa.gov/~gavin/modelE_develop.html">Coding
standards for ModelE</a> and try to conform as nearly as possible to
the (not very onerous) conditions. Unfortunately, we do not have
anybody whose job it is to make sure that added code
conforms. However, every time this happens it makes it harder to keep
the model consistent, and leads to the creation of unnecessary
complications in keeping things straight.</p> 

<p><A name="part3_5"><b>5) HOW-TO add functionality</b></a></p> 

<ul>
  <li><A name="part3_5a"><b>A: Variations on existing code</b></a>

<p>Since all code is now kept within CVS, code history is preserved and
can be retrieved at any time. So for minor modifications to the code
(i.e. slightly different formulation of a particular term), go
straight ahead and modify your version. Compare the results from that
with the standard control run. As you extend your modifications, make
sure to 'commit' your changes at appropriate points (on your branch
only) so that you can retrieve the code from any intermediate (but
functional) point. </p>

  <li><A name="part3_5b"><b>B: Introducing new sub-modules</b></a>

<p>If you want to add a completely new physical module or radically
change an existing one, you will be best off creating a new 'plug and
play' option. Follow the example of the ATURB code (which can replace
DRYCNV if required). The issue is mainly one of keeping the interface
clean and consistent. Unless what you propose will directly influence
multiple parts of the model, it is best to keep your new code as
modular (single column for instance) as possible, and only interact
with the main code through the relevant drivers. </p>

<p>In particular, if there is an existing call to an equivalent routine,
keep the call statement the same for the old and new versions (and you
can add dummy arguments to the old code if required). If you want to
add a new call for which there is no analog, you may want to add a
dummy routine for use in the old version (i.e as in RES_M12.f with
regard to some of the stratospheric code). Put this in a file that you
are making obselete, or even create a new dummy file.</p>

<p>Another way to do this is by using pre-processing directives set from
the rundeck. This is not encouraged except where it would make
inserting a new option much more straightforward. If it is used, limit
its use to the absolute minimum (i.e. to decide whether to call the
new routine or not). We specifically do not want multiply threaded
options with any of the physics routines since that makes maintenance
much more problematic. </p>

<p>In any file where the directive is to used, there must be an </p>

<tt>#include &quot;rundeck_opts.h&quot;</tt><br>

<p>statement at the top of the file. The coding then follows standard
practice: </p>

<tt>#ifdef NEW_FUNCTION<br>
      call new_function(a,b,c)<br>
#endif<br></tt>

<p>To set this option, add a line to the preprocessing option part of the
rundeck.</p>

<tt>
Preprocessor Options<br>
#define NEW_FUNCTION                  ! do new function <br>
End Preprocessor Options<br>
</tt>

<p>The gmake command will recompile the relevant routines every time you
change the option. Note that if options become too commonplace, the
entire model will need to be recompiled every time. Therefore, our
preferred solution is 'plug and play'.</P>

<p>Note that for each new sub-module or pre-processor directive you
create, you should modify the <a href = "OPTIONS.html"> OPTIONS.html
</a> file to document the details.</p>

  <li><A name="part3_5c"><b>C: Introducing a new parameter</b></a> 

<p>Only introduce a new parameter if you would like to be able to vary
it's value at run time without recompiling the model (i.e. an
adjustable parameter, or an option switch for instance). Firstly,
decide who should own the parameter. That is likely to be one of the
physics modules. Since it is likely to be a fundamental part of a
local physics process, it should be declared and defined in the local
physics module. You MUST give it a default value, and ensure it is
tagged with a '@dbparam' comment that explains what it does.</p>

<p>In the initialisation for this module, you need to add a line </p>
<pre>
 call sync_param("NEWPARAM",newparam)
</pre>
<p>which will set the value of newparam from the parameter database, if
it has been set from the input rundeck, or from a restart. (see
the <a href="FAQ.html">FAQ</a> for more details on how this works). </p>

<p>In the rundeck you need only add to the &&PARAMETERS...&&END_PARAMETERS
block a line like this:</p>
<pre>
NEWPARAM=1        ! NEWPARAM sets something for XYZ
</pre>
<p>Of course, you should use a more obvious name! If no value is set in
the rundeck, the default value will be used. </p>

  <li><A name="part3_5d"><b>D: Adding new diagnostics</b></a>

<p>The diagnostic system that the GCM uses is very sophisticated and is
almost certainly sufficient for any new need for diagnostics that
arises. However, it can seem complex and difficult to use. As
improvements in ease of use occur, it will get easier to modify.</p>

<p><b> Adding a new conservation diagnostic: </b> These arrays keep track of
the zonal average of any quantity, and note which routines change
those values. They are useful in understanding the overall
mass/energy/tracer budgets. To add a new conservation quantity, first
write a routine that returns the zonally averaged quantity in
question. Secondly, in the 'init' subroutine for the relevant physical
module, insert a call to 'SET_CON' this sets up the points at which
the diagnostic is called, and how it is output. (see init_DIAG for
more detailed instructions). Thirdly, you must increase NQUANT by 1,
and KCON by 2+number of points at which you are saving the value.</p>

<p>Other diagnostics will be explained if and when we work them out.</P>

  <li><A name="part3_5e"><b>D: Adding extra timing information</b></a>

       <p> If you want more information on how long each part of the
       code takes (for instance if you put in some tracer code, or
       extra physics) the way to do it is to increase the number of
       timing variables such as are output by the program 'qc'. </p>

       <p> Initially, call the routine
       <pre>
       CALL SET_TIMER("NEW PHYSICS",MPHYS)
       </pre>
       Where the text is what will appear in the printout, and MPHYS is
       a locally defined integer variable. At the beginning of
       code you want to profile, add a call to TIMER(MNOW,MORIG) where
       MORIG refers to the timing counter current at this point (in
       order to zero the counter for your routine. At the end of your
       code, call TIMER(MNOW,MPHYS). That's it. </p>
</ul>
       
<p><A name="part3_9"><b>9) HOW-TO read in an external file</b></a></p>

<p>ModelE has introduced a FILEMANAGER system that controls the
assignment of unit numbers and the opening of files. To add a new file
to be read in, first define a short mnemonic for the file
(i.e. "TRSRC" for the tracer source file). This is the name that you
will assign in the rundeck to the file you wish to open. Secondly,
prior to reading in the file, use the routine 'getunit' to assign a
unit number for the file using the mnemonic you gave it. ie.</p>
<pre>
     USE FILEMANAGER
     INTEGER iu_trc1
     ....
     call openunit("TRSRC",iu_trc1,.TRUE.,.TRUE.)
     READ(iu_trc1) DATA1,DATA2....
     call closeunit(iu_trc1)
</pre>
<p>The first logical variable argument is true if the file is to be
opened for unformatted (binary) read/write, .FALSE. for ASCII
input. The second logical variable denotes whether this is an already
existing file or not. These arguments are optional, and default to
TRUE. The line in the rundeck should look something like (depending
on the filename of course):</p>
<pre>
TRSRC=tracer_sources.1970_1980.dat
</pre>
<p>The setup script looks automatically in /u/cmrun, /u/raid and in the
current directory. If the file is elsewhere an absolute or relative
pathname is needed.</p>

<p><A name="part3_10"><b>10) HOW-TO add new variables to the restart
files</b></a></p>

<p>Each module now has only one place that needs to be changed to
accommodate extra variables in the rsf files: io_xyz (where xyz is a
descriptor for the module like ocean, rad, lakes etc.). All
input/output is controlled by these routines. Thus to add a new
variable, simply add it to the list of variables for both the read and
the write statements. Note that you MUST change the MODULE_HEADER
character string if you change what is in the rsf (ie. increment the
number by 1 each time you do this). This is necessary to ensure that
we can distinguish various versions.</p>

<p>There are some complications for variables that can be set in the
NAMELIST, namely, you must decide how this variable gets set as a
function of the initialisation method. Look at io_rad as an example to
follow.</p>

<p><A name="part3_11"><b>11) HOW-TO access variables that are already
calculated somewhere else</b></a></p>

<p>One of the main changes to modelE was to replace common blocks with
Fortran 90 modules. The functionality is much the same, but since they
do not assume anything about where in memory variables are kept, many
of the problems associated with common blocks are alleviated. In order
to make use of a variable from somewhere else in the code, that
variable must be in the relevant MODULE (usually called PHYS_COM, for
ease of remembering). Then in the routine of the module where you wish
to use it you must specifically declare what you want using the USE
statement. For clarity, we are insisting upon using 'USE, only' so
that each variable that you require is explicitly declared, ie.</p>
<pre>
    USE PHYS_COM, only : var1,var2
</pre>
<p>If the name of the variable conflicts with a local variable, you can
use the 'points-to' feature to map the PHYS_COM variable to a new name
(as you may have done with common blocks), i.e.</p>
<pre>
    USE PHYS_COM, only : var1,var2_phys=>var2
</pre>
<p>The arrow should be read as 'points to', and thus var2_phys will be an
alias for var2 in this routine/module only.</p>

<p><A name="part3_12"><b>12) HOW-TO deal with the inevitable bugs you
introduce</b></a></p>

<p>Nobody's code is perfect (least of all ours) and so when coding it is
inevitable that errors are introduced. Some are minor and cause no
obvious sign of distress (these are very difficult to find!), while
others cause the model to crash and burn.</p>

<p>Let's say you've changed something in the model that seemed innocuous,
and then the model crashes. There are three common points that seem to
trap errors: the dynamics, the radiation and the PBL scheme. These
errors will be flagged as either "A>1 in AADVTX" or similar (for
crashes in the dynamics), "In Radia: TL out of range" or similar (in
the radiation), and finally a "stop rtsafe", for a
crash in the PBL.</p>

<p>Do not go looking for errors in any of these routines. What has
generally happened is that you have introduced some wild fluctuation
in some main variable (the temperature, humidity or velocities), or
overwritten some the model variables that control advection and the
like. Check that coming out of the routine you modified, everything is
as it should be (set QCHECK in the rundeck, and include a call to
CHECKT immediately before and after). Also do not bother commenting
out the routine that actually crashed to see if the model can continue
on okay. This routine is the symptom, not the disease.</P>

<p>One additional problem that arises mainly with tracer code is that the
advection code can sometimes produce wild oscillations of the tracer
concentration, which for sensitive tracer physics, can cause no end of
problems. Again, the advection is not to blame! What has happened here
is that the second order moments for the tracer field (the first and
second derivatives at the centre of the grid-box) have somehow become
uncoupled from the mean tracer amount, giving rise to an implied
sub-grid scale profile that is seriously wrong. The biggest mistake is
not to reduce the gradients by the same fraction by which the mean was
reduced in some process. See the document
<a href="http://www.giss.nasa.gov/~gavin/slopes.html">Using the GISS
GCM tracer moments</a> for more details on how to do this
properly. The CLOUDS.f tracer code is a good example of what to do.</P>

<p><A name="part3_13"><b>13) HOW-TO deal with restart problems
(non-reproducibility of results)</b></a></p>

<p>Occasionally after making coding changes the model ceases to be able
to reproduce results. For instance, after a crash, a restart from the
last fort.[12] file does not crash at all, or does so at a different
point. This is a symptom of a restart problem. It should definitely be
fixed, since it is clear evidence that the prognostic code has a real
bug (one that could change the results).</p>

<p>These problems can arise in a number of circumstances:
<ol>
<li> the rsf file is incomplete (a prognostic variable has not been
    saved). This is quite easy to spot and fix.
<li> a variable is not being properly initiallised. This is
    quite tricky to find. What happens is that the first time it is used,
    it is zero, but subsequently it is not. Thus at a restart it is set to
    zero again, changing the results. Try compiling with an option
    (-DEBUG:trap_uninitialized=ON on the SGI compiler) that sets all
    un-initialised numbers to NaN, therefore causing a crash if they are
    used.
<li> out of bounds memory addressing. Occasionally this can also
    result in a restart problem if the memory that is being overwritten is
    used prior to the over-writing. Thus the first time through it is
    clean, but subsequently has the value from the incorrectly addressed
    array. Unfortunately, you cannot set the compiler to catch this,
    since overwriting of arrays, is sometimes done on purpose in the code
    (though we are trying to eliminate that).
<li> parallelisation issues. This is a little trickier and is to do
    with the essentially random order in which calculations are done
    across the processors. For instance, if a random number is used inside
    a parallel loop, the results are irreproducible since random numbers
    are produced in sequence and thus are dependent on the order in which
    they are used.
</ol>
<p>Restart problems can be caught though. There are three times at which
they occur, on the source time step cycle, on the radiation time-step
cycle, or at the daily cycle. Occasionally problems can arise
mid-month if any climatologies are being used. However, most problems
can be detected within the first two hours. </p>

<p>Start from a any fort.[12] file. Save it, and call it rsf0. In the
rundeck (the 'I' file in the run directory), set NDISK=1 in the
database parameter list. This will produce an rsf file every source
time step. Set the end time to be two hours from later than rsf0.
Copy rsf0 to both fort.1 and fort.2. Run the model and save the two
final rsf files as rsf1 and rsf2. Copy rsf1 to both fort.1 and fort.2,
and run the model again. Save the new restart files as rsf1a and rsf2a.</p>

<p>Now you have two copies of the first and second hour rsf files. In
order to compare them, use the program CMPE001 (compiled using 'gmake
aux RUN=E001xyx'). </p>
<pre>
CMPE001 rsf1 rsf1a
</pre>
<p>will go through the rsf files array by array and output any
discrepancies. If no numbers are output, the arrays are identical. If
the first hour rsf files are different, the error must be within INPUT
(or one of the init_XYZ routines). Look at the relevant routine for
the arrays that are highlighted. If however, the first hour checks out
fine, but the second does not, then the error is in the main loop
somewhere. Again, judge by the arrays that are affected which routine
it is likely to be in. If neither set of rsf files differ, then you
need to do this procedure again either starting at hour 4 (assuming a
radaition related problem and a 5 hour radiation time step), or at
hour 23 (assuming a daily related problem). </P>

<p><A name="part3_14"><b>14) HOW-TO get an innovation included in
everybody's versions</b></a></p>

<p>Since you are working on the code within CVS, it is possible to
upload your changes to the main development branch. However, this is
highly unrecommended for the average user, and so I am not going to
tell you how to do it! Instead, please discuss it with one of the
development team. If you wish to make a lot of changes and be part of
the ongoing development of modelE, then please read the
<a href="http://www.giss.nasa.gov/~gavin/gcm_develop.html">developers
guide</a> and then come and talk to me (gavin@giss.nasa.gov).</p>

</BODY>
</HTML>
<P><HR><p>

