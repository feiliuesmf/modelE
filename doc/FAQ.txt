Frequently asked questions about the GISS model
===============================================

Here are some frequently asked questions and some standard responses,
please feel free to add new questions (and answers!), or amend the
response to make it clearer or more complete.

1) Why does GISS use the line number format for fortran files?
2) Is line number format is 'harder' to edit?
3) Don't revision control systems (rcs or cvs) provide equal functionality?
4) Will the update system ever change?
5) Why has all the coding been moved out of main? 
6) Why is modular code so great anyway?
7) Why are there three files for every module, why not just one?
8) How do I know where do find definitions and declarations then?
9) Why doesn't the model produce 'nice' output as it runs?
10) Something is wrong with the advection, my tracers are going haywire!
11) Why should I switch to using modelE?
12) Why do I get single precision answers from double precision
variables?, and what are all those 'd0' doing?

===========================================================================

1) Why does GISS use the line number format for fortran files?

Line number format is the practive of using the first 8 characters of
a line to insert line number information in a 'F8.3' format.

Historically, this is a holdover from the days of the punchcard when
all lines required a line number. Subsequently, it was used at GISS to
make additions/corrections to files without having to copy the entire
rest of the code (the update system). Further refinements have 
led to functional updates that allow the 'piggy-backing' of specific
functionality (such as tracer code, or ocean coupling) on top of the
underlying model code in a relatively model-version independent way.  
We have also found it very useful in tracking bugs, notifying users
about code changes and referencing in general. 

In modelE line number format has been replaced by the CVS revision
control system and preprocessing options. 

2) Is line number format is 'harder' to edit?

Since the format is written in ASCII is just as easy as any other text
format to edit in any standard editor. In addition we have tools which
work very well that 
 a) allow standard fortran mode in Emacs to work with line-numbers
   (giss-fortran-mode.el)
 b) utilities that fill-in any missing line numbers, so that you
   don't ever need to put them in by hand (fillnum). This could be
   combined with the makefile, so that the it would occur
   automatically 
 c) you can choose whatever format you like to edit (.U file,
 a .f file (line numbers first or last)) with options to upd

3) Don't revision control systems (rcs or cvs) provide 
equal functionality?

One part of the update file system (of which line numbers are
part) is indeed to save space and store only changes from a base file
and this is replicated - and improved upon with rcs or cvs. However,
the other part of the system involves the addition of functionality
that is generally independent of the base code (i.e the tracer code,
the stratospheric code, the coupling to the ocean, options for
diagnostic output etc), which can be applied directly to any version
of the base code, hopefully with only minimal changes. This is not
replicated by standard rcs/cvs systems (and indeed they do not
try). This functionality is to some extent similar to the use of
pre-processor directives, but as the number of options grow (as they
will), this produces unwieldy and overly complicated base code.
Thirdly, line numbers are a very easy way to refer to code sections,
either to describe what is going on, or to refer to specific lines, for
instance, when a bug is discovered. 

4) Will the update system ever change?

We have already seen an increase in functionality of the update system
that have made it much more useful for precisely the functions that
rcs/cvs does not cover. Further improvements are likely. 

5) Why has all the coding been moved out of main? 

In order to increase the modularity of the code, many tasks that were
previously in main and input (input/output, initialisations,
diagnostics etc.) have been moved to the relevant module. Thus, main
should not vary as much between model versions. Also, changes to a
module (to the number of prognostic variables, the functionality etc.)
should now only concern that module and not the rest of the
model. This should make it easier to 'plug and play' new
functionality. 

6) Why is modular code so great anyway?

So that if you want to change something, you only need to do it in the
part of the code directly affected. There should be much less
unforseen consequences to seemingly minor changes.

7) Why are there three files for every module, why not just one?

There are generally three logical parts of each module: a common block
(that owns the variables on the main model grid and/or saves output
from a module that might be used by another part of the code), the
local physics (for instance, the pure 1D column physics) and the
drivers (the programs that access the local physics routines, do
initiallisation etc.). The reason that they are in seperate files is
mainly because of the logical dependencies between the main model and
module variables. Consider a situation where the module needs
information from another module - i.e. there is a USE statement in one
of the drivers. Conceivably, that module might USE a variable from
this module also. Since we now use an automatically generated list of
dependencies in the makefile, this would create a circular dependency
if the USE statements and the variable definitions were in the same
file. Therefore, at minimum the common block and the drivers must be
seperated. We choose generally to make the local physics a seperate
file also because it is not usually dependent on anything except the
CONSTANT module and possibly the main model common block. Thus it does
not need to be recompiled everytime something in the drivers or common
block changes. However, sometimes the local physics is in the same
file as the COM module.

8) How do I know where do find definitions and declarations then?

The rules are relatively simple (but not yet implemented 100% of the
time). 
- Variables defined on the model grid are in the COM file.
- Module specific parameters are in the local physics module.
- local variables are defined wherever they are needed.
- Variables from other parts of the code are listed in the USE only
  statements. 
- One exception to this is when local parameters are required by another
  part of the model (i.e. for the input NAMELIST), then the variable
  might be defined in the local physics module, USE'd by the COM
  module and only accessed through COM. 
- Drivers can USE both the COM variables and the local physics parameters.

9) Why doesn't the model produce 'nice' output as it runs?

The GISS GCM output is of the form of accumulation files, and since
the accumulated quantities are neither averaged or scaled, looking
directly at these 'acc' files is not very illuminating. So it is a
fact that the running output is not 'nice'. However there are a number
of reasons why we do it this way. Firstly, the accumualted arrays are
generally the basic model values. The 'nice' diagnostics that are
required are generally a function of a number of these
variables. Accumualted arrays and files can be concatenated very
easily (and thus averaged trivially) without having to worry about the
length of time each array was accumulated (say a different number of
days in two different months). The average of derived quantities (such
as the albedo) is not the same as the quantity derived from the
average (which is usually what is required). Accumulated arrays allow
you to do both deepending on what is needed. A great many diagnostics
can be derived after the fact, without having to have thought about
them ahead of time. 

10) Something is wrong with the advection, my tracers are going haywire!

This is not a problem in the advection. The GISS dynamical core is
unique in that it uses more information than just the mean tracer
amount in a particular grid-box. We currently use two flavours of
tracer advection, the linear and the quadratic upstream schemes. The
linear scheme carries 3 first order moments along with the mean, while
the quadratic scheme carries an additional 6 second order
moments. These can be thought of as representing the spatial gradients
of the tracer concentration at the centre of a gridbox. Thus a higher
degree of accuracy for the tracer distribution in the box can be found
as a Taylor series expansion in the moments. This is used in the
advection routines to accurately move mass and tracer mass from box to
box. However, as should be clear, if the moments are incorrect or
corrupted in any way, the advection will be compromised, even to the
point where negaitve tracer amounts might appear. This is usually what
has happened when the model crashes after advecting tracers.  

What could cause the the moments to be corrupted? Generally, the
coding of the tracers did not consider the effects on the moments of a
particular physical process. The most serious omission is not to
reduce the moments in the same proportion as the tracer mass is
reduced. This omission can leave tracer moments significantly larger
than the mean tracer amount, and implies a sub-grid scale tracer
profile that is not positive definite. Please read the document "Using
tracer moments in the GISS GCM" for further information on how to use
the moments in a useful fashion.

11) Why should I switch to using modelE?

It is of course up to you. However, there are a number of reasons why
it makes sense for you to make the effort involved in upgrading.

- modelE fixed a number of bugs (some major, some minor) that may
  still exist in your code.
- subsequent changes and upgrades for modelE will be significantly
  easy than it was for model II'
- adding diagnostics is much more straightforward
- acc files now have more information and thus 'pd'-like programs are
  now more robust
- modelE is double precision throughout
- modelE will eventually be the only model version supported by the programmers. 
- modelE is more modular, more flexible and easier to understand
- modelE has made explicit most of the dependencies that were hidden
  in model II'. Thus minor changes are less likely to have devastating
  knock on effects.
- modelE is written using a lot of Fortran 90, and a lot less Fortran 66.
- modelE comes with automatic Makefile generation from the rundeck.
- modelE comes ready for parallelisation, coupling and tracers.

12) Why do I get single precision answers from double precision
variables?, and what are all those 'd0' doing?

All numbers in the GCM should be accurate to the degree of their
representation , however, many are not. This mostly stems from the
automatic conversion that takes place when a single precision or
integer number is converted to a double precision variable.
In the following examples the double precision variables will only be
accurate to 6 or so decimal places (instead of the 12 or so expected).

      REAL*8 X

      X = 0.1                  =>   0.10000000149011612
      X = 1/3                  =>   0.       (integer division)
      X = 1./3.                =>   0.3333333432674408
      X = 1./3                 =>   0.3333333432674408
      X = 0.3333333333333333   =>   0.3333333432674408  (!!!!)

To get double precision results you must use 'd' ie.

      X=0.1d0  or 1d-1
      X=1d0/3d0  or 1./3d0   or even 1d0/3 

Note that for decimals expressable exactly in binary formulation,
there are no problems, ie. X=0.5 is the same as X=5d-1. Where integer
division is concerned, the integer is converted to the type of the
numerator (I think). Thus 1./IM gives only single precision. 
REAL*8 :: FIM = IM, BYIM = 1./FIM 
gives double precision (since the denominator is already double precision).

On some compilers there is a compiler option that removes these
problems, but not all. Hence for maximum portability we are trying to
be explicit about writing those 'd0's out.

